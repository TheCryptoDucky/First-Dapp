{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { createFetchMiddleware, providerFromEngine } from '@toruslabs/base-controllers';\nimport { mergeMiddleware, createAsyncMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, isHexStrict, WalletInitializationError } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport bs58 from 'bs58';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { PublicKey, Connection, Keypair } from '@solana/web3.js';\nimport nacl from '@toruslabs/tweetnacl-js';\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n\n    return next();\n  };\n}\n\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n\n    return next();\n  };\n}\n\nfunction createConfigMiddleware(providerConfig) {\n  const {\n    chainId\n  } = providerConfig;\n  return mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig)]);\n}\n\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\n\nfunction createGetAccountsMiddleware(_ref) {\n  let {\n    getAccounts\n  } = _ref;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"getAccounts\") return next();\n    if (!getAccounts) throw new Error(\"WalletMiddleware - opts.getAccounts not provided\"); // This calls from the prefs controller\n\n    const accounts = await getAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\n\nfunction createRequestAccountsMiddleware(_ref2) {\n  let {\n    requestAccounts\n  } = _ref2;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"requestAccounts\") return next();\n    if (!requestAccounts) throw new Error(\"WalletMiddleware - opts.requestAccounts not provided\"); // This calls the UI login function\n\n    const accounts = await requestAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\n\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== targetMethod) return next();\n    if (!handler) throw new Error(\"WalletMiddleware - \".concat(targetMethod, \" not provided\"));\n    const result = await handler(request);\n    response.result = result;\n    return undefined;\n  });\n}\n\nfunction createSolanaMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    requestAccounts,\n    signTransaction,\n    signAndSendTransaction,\n    signAllTransactions,\n    signMessage,\n    getPrivateKey,\n    getSecretKey\n  } = providerHandlers;\n  return mergeMiddleware([createRequestAccountsMiddleware({\n    requestAccounts\n  }), createGetAccountsMiddleware({\n    getAccounts\n  }), createGenericJRPCMiddleware(\"signTransaction\", signTransaction), createGenericJRPCMiddleware(\"signAndSendTransaction\", signAndSendTransaction), createGenericJRPCMiddleware(\"signAllTransactions\", signAllTransactions), createGenericJRPCMiddleware(\"signMessage\", signMessage), createGenericJRPCMiddleware(\"solanaPrivateKey\", getPrivateKey), createGenericJRPCMiddleware(\"solanaSecretKey\", getSecretKey)]);\n}\n\nfunction createChainSwitchMiddleware(_ref3) {\n  let {\n    addNewChainConfig,\n    switchSolanaChain\n  } = _ref3;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"addSolanaChain\", addNewChainConfig), createGenericJRPCMiddleware(\"switchSolanaChain\", switchSolanaChain)]);\n}\n\nfunction createAccountMiddleware(_ref4) {\n  let {\n    updatePrivatekey\n  } = _ref4;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"updateAccount\", updatePrivatekey)]);\n}\n\nfunction ownKeys$3(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$3(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass BaseInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$3(_objectSpread$3({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    const engine = new JRPCEngine();\n    const providerHandlers = this.getProviderHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    engine.push(solanaMiddleware);\n    const configMiddleware = createConfigMiddleware(this.config.chainConfig);\n    engine.push(configMiddleware);\n    const injectedProviderProxy = this.getInjectedProviderProxy(injectedProvider);\n\n    if (injectedProviderProxy) {\n      engine.push(injectedProviderProxy);\n    }\n\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async lookupNetwork() {\n    const {\n      chainConfig\n    } = this.config;\n    this.update({\n      chainId: chainConfig.chainId\n    });\n    return chainConfig.chainId || \"\";\n  }\n\n  getInjectedProviderProxy(_) {\n    return undefined;\n  }\n\n}\n\nconst getBaseProviderHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [];\n    },\n    getAccounts: async () => injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [],\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getSecretKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signTransaction: async req => {\n      const transaction = await injectedProvider.signTransaction(req.params.message);\n      return transaction;\n    },\n    signMessage: async req => {\n      const message = await injectedProvider.signMessage(req.params.message);\n      return message;\n    },\n    signAllTransactions: async req => {\n      var _req$params, _req$params2;\n\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message) || !((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const transaction = await injectedProvider.signAllTransactions(req.params.message);\n      return transaction;\n    },\n    signAndSendTransaction: async req => {\n      const txRes = await injectedProvider.signAndSendTransaction(req.params.message);\n      return {\n        signature: txRes.signature\n      };\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$2(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$2(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nfunction createInjectedProviderProxyMiddleware(provider) {\n  return createAsyncMiddleware(async (req, res, _next) => {\n    const result = await provider.request(_objectSpread$2({}, req));\n    res.result = result;\n  });\n}\n\nclass PhantomInjectedProvider extends BaseInjectedProvider {\n  getProviderHandlers(injectedProvider) {\n    return getBaseProviderHandlers(injectedProvider);\n  }\n\n  getInjectedProviderProxy(injectedProvider) {\n    return createInjectedProviderProxyMiddleware(injectedProvider);\n  }\n\n}\n\nconst getSlopeHandlers = (injectedProvider, getProviderEngineProxy) => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      const {\n        data\n      } = await injectedProvider.connect();\n      return [data.publicKey];\n    },\n    getAccounts: async () => {\n      const {\n        data\n      } = await injectedProvider.connect();\n      return [data.publicKey];\n    },\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getSecretKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signTransaction: async req => {\n      const txMessage = req.params.message;\n      if (!txMessage) throw ethErrors.rpc.invalidRequest({\n        message: \"Invalid transaction message\"\n      });\n      const {\n        data\n      } = await injectedProvider.signTransaction(bs58.encode(txMessage.serializeMessage()));\n      if (!data.publicKey || !data.signature) throw new Error(\"Invalid signature from slope wallet\");\n      const publicKey = new PublicKey(data.publicKey);\n      const signature = bs58.decode(data.signature);\n      txMessage.addSignature(publicKey, signature);\n      return txMessage;\n    },\n    signMessage: async req => {\n      const response = await injectedProvider.signMessage(req.params.message);\n      return bs58.decode(response.data.signature);\n    },\n    signAndSendTransaction: async req => {\n      const provider = getProviderEngineProxy();\n      if (!provider) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const txMessage = req.params.message;\n      if (!txMessage) throw ethErrors.rpc.invalidRequest({\n        message: \"Invalid transaction message\"\n      });\n      const {\n        data\n      } = await injectedProvider.signTransaction(bs58.encode(txMessage.serializeMessage()));\n      if (!data.publicKey || !data.signature) throw new Error(\"Invalid signature from slope wallet\");\n      const publicKey = new PublicKey(data.publicKey);\n      const signature = bs58.decode(data.signature);\n      txMessage.addSignature(publicKey, signature);\n      const chainConfig = await provider.request({\n        method: \"solana_provider_config\",\n        params: []\n      });\n      const conn = new Connection(chainConfig.rpcTarget);\n      const res = await conn.sendRawTransaction(txMessage.serialize());\n      return {\n        signature: res\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params, _req$params2, _data$signatures;\n\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message) || !((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const allTxns = req.params.message;\n      const {\n        length\n      } = allTxns;\n      const unsignedTx = [];\n\n      for (let i = 0; i < length; i++) {\n        unsignedTx.push(bs58.encode(req.params.message[i].serializeMessage()));\n      }\n\n      const {\n        msg,\n        data\n      } = await injectedProvider.signAllTransactions(unsignedTx);\n      if (!data.publicKey || ((_data$signatures = data.signatures) === null || _data$signatures === void 0 ? void 0 : _data$signatures.length) !== length) throw new Error(msg);\n      const publicKey = new PublicKey(data.publicKey);\n\n      for (let i = 0; i < length; i++) {\n        const signature = bs58.decode(data.signatures[i]);\n        allTxns[i].addSignature(publicKey, signature);\n      }\n\n      return allTxns;\n    }\n  };\n  return providerHandlers;\n};\n\nclass SlopeInjectedProxyProvider extends BaseInjectedProvider {\n  getProviderHandlers(injectedProvider) {\n    return getSlopeHandlers(injectedProvider, this.getProviderEngineProxy.bind(this));\n  }\n\n}\n\nconst getSolflareHandlers = (injectedProvider, getProviderEngineProxy) => {\n  const solflareProviderHandlers = getBaseProviderHandlers(injectedProvider);\n\n  solflareProviderHandlers.signAndSendTransaction = async req => {\n    const provider = getProviderEngineProxy();\n    if (!provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const transaction = await injectedProvider.signTransaction(req.params.message);\n    const chainConfig = await provider.request({\n      method: \"solana_provider_config\",\n      params: []\n    });\n    const conn = new Connection(chainConfig.rpcTarget);\n    const res = await conn.sendRawTransaction(transaction.serialize());\n    return {\n      signature: res\n    };\n  };\n\n  return solflareProviderHandlers;\n};\n\nclass SolflareInjectedProvider extends BaseInjectedProvider {\n  getProviderHandlers(injectedProvider) {\n    return getSolflareHandlers(injectedProvider, this.getProviderEngineProxy.bind(this));\n  }\n\n}\n\nconst getSolletHandlers = (injectedProvider, getProviderEngineProxy) => {\n  const providerHandlers = getBaseProviderHandlers(injectedProvider);\n\n  providerHandlers.signMessage = async req => {\n    const {\n      signature\n    } = await injectedProvider.sign(req.params.message, \"utf8\");\n    return signature;\n  };\n\n  providerHandlers.signAndSendTransaction = async req => {\n    const provider = getProviderEngineProxy();\n    if (!provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const transaction = await injectedProvider.signTransaction(req.params.message);\n    const chainConfig = await provider.request({\n      method: \"solana_provider_config\",\n      params: []\n    });\n    const conn = new Connection(chainConfig.rpcTarget);\n    const res = await conn.sendRawTransaction(transaction.serialize());\n    return {\n      signature: res\n    };\n  };\n\n  return providerHandlers;\n};\n\nclass SolletInjectedProvider extends BaseInjectedProvider {\n  getProviderHandlers(injectedProvider) {\n    return getSolletHandlers(injectedProvider, this.getProviderEngineProxy.bind(this));\n  }\n\n}\n\nconst getTorusHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_requestAccounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_accounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getSecretKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signMessage: async req => {\n      var _req$params;\n\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const message = await injectedProvider.signMessage(req.params.message);\n      return message;\n    },\n    signTransaction: async req => {\n      var _req$params2;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const txMessage = req.params.message;\n      const response = await injectedProvider.signTransaction(txMessage);\n      return response;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const txMessage = req.params.message;\n      const response = await injectedProvider.sendTransaction(txMessage);\n      return {\n        signature: response\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params4, _req$params5;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const transactions = req.params.message;\n      const response = await injectedProvider.signAllTransactions(transactions);\n      return response;\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$1(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread$1(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass TorusInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$1(_objectSpread$1({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    this.handleInjectedProviderUpdate(injectedProvider);\n    await this.setupEngine(injectedProvider);\n  }\n\n  async lookupNetwork() {\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Torus solana provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedChainId = await this.provider.request({\n      method: \"solana_chainId\"\n    });\n    const connectedHexChainId = isHexStrict(connectedChainId.toString()) ? connectedChainId : \"0x\".concat(parseInt(connectedChainId, 10).toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.update({\n      chainId: connectedHexChainId\n    });\n    this.provider.emit(\"connect\", {\n      chainId: this.state.chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return this.state.chainId;\n  }\n\n  async setupEngine(injectedProvider) {\n    const providerHandlers = getTorusHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async handleInjectedProviderUpdate(injectedProvider) {\n    injectedProvider.on(\"accountsChanged\", async accounts => {\n      this.provider.emit(\"accountsChanged\", accounts);\n    });\n    injectedProvider.on(\"chainChanged\", async chainId => {\n      const connectedHexChainId = isHexStrict(chainId) ? chainId : \"0x\".concat(parseInt(chainId, 10).toString(16)); // Check if chainId changed and trigger event\n\n      this.configure({\n        chainConfig: _objectSpread$1(_objectSpread$1({}, this.config.chainConfig), {}, {\n          chainId: connectedHexChainId\n        })\n      });\n      await this.setupProvider(injectedProvider);\n    });\n  }\n\n}\n\nasync function getProviderHandlers(_ref) {\n  let {\n    privKey,\n    getProviderEngineProxy\n  } = _ref;\n\n  const keyPairGenerator = () => {\n    return Keypair.fromSecretKey(Buffer.from(privKey, \"hex\"));\n  };\n\n  if (typeof privKey !== \"string\") throw WalletInitializationError.invalidParams(\"privKey must be a string\");\n  const keyPair = keyPairGenerator();\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return [keyPair.publicKey.toBase58()];\n    },\n    getAccounts: async () => [keyPair.publicKey.toBase58()],\n    getPrivateKey: async () => privKey,\n    getSecretKey: async () => bs58.encode(keyPair.secretKey),\n    signTransaction: async req => {\n      var _req$params;\n\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const transaction = req.params.message;\n      transaction.partialSign(keyPair);\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params2;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const signedMsg = nacl.sign.detached(req.params.message, keyPair.secretKey);\n      return signedMsg;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const _providerEngineProxy = getProviderEngineProxy();\n\n      if (!_providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const transaction = req.params.message;\n      transaction.sign(keyPair);\n      const sig = await _providerEngineProxy.request({\n        method: \"sendTransaction\",\n        params: [bs58.encode(transaction.serialize())]\n      });\n      return {\n        signature: sig\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params4, _req$params5, _req$params6;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const txns = (_req$params6 = req.params) === null || _req$params6 === void 0 ? void 0 : _req$params6.message;\n\n      for (const tx of txns || []) {\n        const transaction = tx;\n        transaction.partialSign(keyPair);\n      }\n\n      return txns;\n    }\n  };\n  return providerHandlers;\n}\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass SolanaPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(privKey) {\n    const providerHandlers = await getProviderHandlers({\n      privKey,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(this.getChainSwitchMiddleware());\n    engine.push(this.getAccountMiddleware());\n    engine.push(solanaMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"requestAccounts\"\n        })\n      });\n    }\n  }\n\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n    await this.setupProvider(privKey);\n  }\n\n  async lookupNetwork() {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const health = await this._providerEngineProxy.request({\n      method: \"getHealth\",\n      params: []\n    });\n    const {\n      chainConfig\n    } = this.config;\n    if (health !== \"ok\") throw WalletInitializationError.rpcConnectionError(\"Failed to lookup network for following rpc target: \".concat(chainConfig.rpcTarget));\n    this.update({\n      chainId: chainConfig.chainId\n    });\n\n    if (this.state.chainId !== chainConfig.chainId) {\n      this.provider.emit(\"chainChanged\", this.state.chainId);\n      this.provider.emit(\"connect\", {\n        chainId: this.state.chainId\n      });\n    }\n\n    return this.state.chainId;\n  }\n\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addNewChainConfig: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = req.params;\n        if (!chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n        if (!rpcUrls || rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n        if (!nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n        this.addChain({\n          chainNamespace: CHAIN_NAMESPACES.SOLANA,\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"SOL\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Solana\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchSolanaChain: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n        await this.switchChain(req.params);\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.privateKey) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n        const {\n          privateKey\n        } = req.params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n\n}\n\n_defineProperty(SolanaPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new SolanaPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nclass SolanaWallet {\n  constructor(provider) {\n    _defineProperty(this, \"provider\", void 0);\n\n    this.provider = provider;\n  }\n\n  async requestAccounts() {\n    const accounts = await this.provider.request({\n      method: \"requestAccounts\",\n      params: {}\n    });\n    return accounts;\n  }\n\n  async signAndSendTransaction(transaction) {\n    const {\n      signature\n    } = await this.provider.request({\n      method: \"signAndSendTransaction\",\n      params: {\n        message: transaction\n      }\n    });\n    return {\n      signature\n    };\n  }\n\n  async signTransaction(transaction) {\n    const signedTransaction = await this.provider.request({\n      method: \"signTransaction\",\n      params: {\n        message: transaction\n      }\n    });\n    return signedTransaction;\n  }\n\n  async signAllTransactions(transactions) {\n    const signedTransactions = await this.provider.request({\n      method: \"signAllTransactions\",\n      params: {\n        message: transactions\n      }\n    });\n    return signedTransactions;\n  }\n\n  async signMessage(data) {\n    const response = await this.provider.request({\n      method: \"signMessage\",\n      params: {\n        message: data\n      }\n    });\n    return response;\n  }\n\n  async request(args) {\n    const result = await this.provider.request(args);\n    return result;\n  }\n\n}\n\nexport { PhantomInjectedProvider, SlopeInjectedProxyProvider, SolanaPrivateKeyProvider, SolanaWallet, SolflareInjectedProvider, SolletInjectedProvider, TorusInjectedProvider };","map":{"version":3,"sources":["../src/rpc/JrpcClient.ts","../src/rpc/solanaRpcMiddlewares.ts","../src/providers/injectedProviders/base/baseInjectedProvider.ts","../src/providers/injectedProviders/base/providerHandlers.ts","../src/providers/injectedProviders/injectedProviderProxy.ts","../src/providers/injectedProviders/phantom/phantomInjectedProvider.ts","../src/providers/injectedProviders/slope/providerHandlers.ts","../src/providers/injectedProviders/slope/slopeInjectedProvider.ts","../src/providers/injectedProviders/solflare/providerHandlers.ts","../src/providers/injectedProviders/solflare/solflareInjectedProvider.ts","../src/providers/injectedProviders/sollet/providerHandlers.ts","../src/providers/injectedProviders/sollet/solletInjectedProvider.ts","../src/providers/injectedProviders/torus/providerHandlers.ts","../src/providers/injectedProviders/torus/torusInjectedProvider.ts","../src/providers/privateKeyProvider/solanaPrivateKeyUtils.ts","../src/providers/privateKeyProvider/solanaPrivateKeyProvider.ts","../src/solanaWallet.ts"],"names":["req","res","end","next","chainId","mergeMiddleware","createChainIdMiddleware","createProviderConfigMiddleware","rpcTarget","fetchMiddleware","createFetchMiddleware","networkMiddleware","createConfigMiddleware","getAccounts","createAsyncMiddleware","method","accounts","response","requestAccounts","result","handler","getSecretKey","createRequestAccountsMiddleware","createGetAccountsMiddleware","createGenericJRPCMiddleware","createChainSwitchMiddleware","switchSolanaChain","updatePrivatekey","constructor","state","config","chainConfig","chainNamespace","CHAIN_NAMESPACES","SOLANA","switchChain","Promise","setupProvider","engine","providerHandlers","solanaMiddleware","createSolanaMiddleware","configMiddleware","injectedProviderProxy","provider","providerFromEngine","lookupNetwork","getInjectedProviderProxy","getBaseProviderHandlers","injectedProvider","bs58","getPrivateKey","ethErrors","signTransaction","transaction","signMessage","message","signAllTransactions","signAndSendTransaction","txRes","signature","getProviderHandlers","createInjectedProviderProxyMiddleware","getSlopeHandlers","data","txMessage","publicKey","getProviderEngineProxy","code","params","conn","allTxns","length","unsignedTx","i","getSolflareHandlers","solflareProviderHandlers","getSolletHandlers","getTorusHandlers","transactions","connectedChainId","connectedHexChainId","isHexStrict","parseInt","WalletInitializationError","setupEngine","handleInjectedProviderUpdate","_objectSpread","keyPairGenerator","Keypair","Buffer","keyPair","signedMsg","nacl","_providerEngineProxy","sig","txns","SolanaPrivateKeyProvider","providerFactory","enable","createJsonRpcClient","updateAccount","existingKey","privKey","health","getChainSwitchMiddleware","chainSwitchHandlers","addNewChainConfig","nativeCurrency","rpcUrls","ticker","tickerName","displayName","blockExplorer","chainSwitchMiddleware","getAccountMiddleware","accountHandlers","privateKey","createAccountMiddleware","SolanaWallet","signedTransaction","signedTransactions","request"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { createFetchMiddleware, providerFromEngine } from '@toruslabs/base-controllers';\nimport { mergeMiddleware, createAsyncMiddleware, JRPCEngine } from '@toruslabs/openlogin-jrpc';\nimport { CHAIN_NAMESPACES, isHexStrict, WalletInitializationError } from '@web3auth/base';\nimport { BaseProvider } from '@web3auth/base-provider';\nimport bs58 from 'bs58';\nimport { ethErrors } from 'eth-rpc-errors';\nimport { PublicKey, Connection, Keypair } from '@solana/web3.js';\nimport nacl from '@toruslabs/tweetnacl-js';\n\nfunction createChainIdMiddleware(chainId) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_chainId\") {\n      res.result = chainId;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createProviderConfigMiddleware(providerConfig) {\n  return (req, res, next, end) => {\n    if (req.method === \"solana_provider_config\") {\n      res.result = providerConfig;\n      return end();\n    }\n\n    return next();\n  };\n}\nfunction createConfigMiddleware(providerConfig) {\n  const {\n    chainId\n  } = providerConfig;\n  return mergeMiddleware([createChainIdMiddleware(chainId), createProviderConfigMiddleware(providerConfig)]);\n}\nfunction createJsonRpcClient(providerConfig) {\n  const {\n    rpcTarget\n  } = providerConfig;\n  const fetchMiddleware = createFetchMiddleware({\n    rpcTarget\n  });\n  const networkMiddleware = mergeMiddleware([createConfigMiddleware(providerConfig), fetchMiddleware]);\n  return {\n    networkMiddleware,\n    fetchMiddleware\n  };\n}\n\nfunction createGetAccountsMiddleware(_ref) {\n  let {\n    getAccounts\n  } = _ref;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"getAccounts\") return next();\n    if (!getAccounts) throw new Error(\"WalletMiddleware - opts.getAccounts not provided\"); // This calls from the prefs controller\n\n    const accounts = await getAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\nfunction createRequestAccountsMiddleware(_ref2) {\n  let {\n    requestAccounts\n  } = _ref2;\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== \"requestAccounts\") return next();\n    if (!requestAccounts) throw new Error(\"WalletMiddleware - opts.requestAccounts not provided\"); // This calls the UI login function\n\n    const accounts = await requestAccounts(request);\n    response.result = accounts;\n    return undefined;\n  });\n}\nfunction createGenericJRPCMiddleware(targetMethod, handler) {\n  return createAsyncMiddleware(async (request, response, next) => {\n    const {\n      method\n    } = request;\n    if (method !== targetMethod) return next();\n    if (!handler) throw new Error(\"WalletMiddleware - \".concat(targetMethod, \" not provided\"));\n    const result = await handler(request);\n    response.result = result;\n    return undefined;\n  });\n}\nfunction createSolanaMiddleware(providerHandlers) {\n  const {\n    getAccounts,\n    requestAccounts,\n    signTransaction,\n    signAndSendTransaction,\n    signAllTransactions,\n    signMessage,\n    getPrivateKey,\n    getSecretKey\n  } = providerHandlers;\n  return mergeMiddleware([createRequestAccountsMiddleware({\n    requestAccounts\n  }), createGetAccountsMiddleware({\n    getAccounts\n  }), createGenericJRPCMiddleware(\"signTransaction\", signTransaction), createGenericJRPCMiddleware(\"signAndSendTransaction\", signAndSendTransaction), createGenericJRPCMiddleware(\"signAllTransactions\", signAllTransactions), createGenericJRPCMiddleware(\"signMessage\", signMessage), createGenericJRPCMiddleware(\"solanaPrivateKey\", getPrivateKey), createGenericJRPCMiddleware(\"solanaSecretKey\", getSecretKey)]);\n}\nfunction createChainSwitchMiddleware(_ref3) {\n  let {\n    addNewChainConfig,\n    switchSolanaChain\n  } = _ref3;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"addSolanaChain\", addNewChainConfig), createGenericJRPCMiddleware(\"switchSolanaChain\", switchSolanaChain)]);\n}\nfunction createAccountMiddleware(_ref4) {\n  let {\n    updatePrivatekey\n  } = _ref4;\n  return mergeMiddleware([createGenericJRPCMiddleware(\"updateAccount\", updatePrivatekey)]);\n}\n\nfunction ownKeys$3(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$3(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$3(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$3(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass BaseInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$3(_objectSpread$3({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    const engine = new JRPCEngine();\n    const providerHandlers = this.getProviderHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    engine.push(solanaMiddleware);\n    const configMiddleware = createConfigMiddleware(this.config.chainConfig);\n    engine.push(configMiddleware);\n    const injectedProviderProxy = this.getInjectedProviderProxy(injectedProvider);\n\n    if (injectedProviderProxy) {\n      engine.push(injectedProviderProxy);\n    }\n\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async lookupNetwork() {\n    const {\n      chainConfig\n    } = this.config;\n    this.update({\n      chainId: chainConfig.chainId\n    });\n    return chainConfig.chainId || \"\";\n  }\n\n  getInjectedProviderProxy(_) {\n    return undefined;\n  }\n\n}\n\nconst getBaseProviderHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [];\n    },\n    getAccounts: async () => injectedProvider.publicKey ? [bs58.encode(injectedProvider.publicKey.toBytes())] : [],\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getSecretKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signTransaction: async req => {\n      const transaction = await injectedProvider.signTransaction(req.params.message);\n      return transaction;\n    },\n    signMessage: async req => {\n      const message = await injectedProvider.signMessage(req.params.message);\n      return message;\n    },\n    signAllTransactions: async req => {\n      var _req$params, _req$params2;\n\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message) || !((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const transaction = await injectedProvider.signAllTransactions(req.params.message);\n      return transaction;\n    },\n    signAndSendTransaction: async req => {\n      const txRes = await injectedProvider.signAndSendTransaction(req.params.message);\n      return {\n        signature: txRes.signature\n      };\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$2(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$2(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$2(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$2(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nfunction createInjectedProviderProxyMiddleware(provider) {\n  return createAsyncMiddleware(async (req, res, _next) => {\n    const result = await provider.request(_objectSpread$2({}, req));\n    res.result = result;\n  });\n}\n\nclass PhantomInjectedProvider extends BaseInjectedProvider {\n  getProviderHandlers(injectedProvider) {\n    return getBaseProviderHandlers(injectedProvider);\n  }\n\n  getInjectedProviderProxy(injectedProvider) {\n    return createInjectedProviderProxyMiddleware(injectedProvider);\n  }\n\n}\n\nconst getSlopeHandlers = (injectedProvider, getProviderEngineProxy) => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      const {\n        data\n      } = await injectedProvider.connect();\n      return [data.publicKey];\n    },\n    getAccounts: async () => {\n      const {\n        data\n      } = await injectedProvider.connect();\n      return [data.publicKey];\n    },\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getSecretKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signTransaction: async req => {\n      const txMessage = req.params.message;\n      if (!txMessage) throw ethErrors.rpc.invalidRequest({\n        message: \"Invalid transaction message\"\n      });\n      const {\n        data\n      } = await injectedProvider.signTransaction(bs58.encode(txMessage.serializeMessage()));\n      if (!data.publicKey || !data.signature) throw new Error(\"Invalid signature from slope wallet\");\n      const publicKey = new PublicKey(data.publicKey);\n      const signature = bs58.decode(data.signature);\n      txMessage.addSignature(publicKey, signature);\n      return txMessage;\n    },\n    signMessage: async req => {\n      const response = await injectedProvider.signMessage(req.params.message);\n      return bs58.decode(response.data.signature);\n    },\n    signAndSendTransaction: async req => {\n      const provider = getProviderEngineProxy();\n      if (!provider) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const txMessage = req.params.message;\n      if (!txMessage) throw ethErrors.rpc.invalidRequest({\n        message: \"Invalid transaction message\"\n      });\n      const {\n        data\n      } = await injectedProvider.signTransaction(bs58.encode(txMessage.serializeMessage()));\n      if (!data.publicKey || !data.signature) throw new Error(\"Invalid signature from slope wallet\");\n      const publicKey = new PublicKey(data.publicKey);\n      const signature = bs58.decode(data.signature);\n      txMessage.addSignature(publicKey, signature);\n      const chainConfig = await provider.request({\n        method: \"solana_provider_config\",\n        params: []\n      });\n      const conn = new Connection(chainConfig.rpcTarget);\n      const res = await conn.sendRawTransaction(txMessage.serialize());\n      return {\n        signature: res\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params, _req$params2, _data$signatures;\n\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message) || !((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const allTxns = req.params.message;\n      const {\n        length\n      } = allTxns;\n      const unsignedTx = [];\n\n      for (let i = 0; i < length; i++) {\n        unsignedTx.push(bs58.encode(req.params.message[i].serializeMessage()));\n      }\n\n      const {\n        msg,\n        data\n      } = await injectedProvider.signAllTransactions(unsignedTx);\n      if (!data.publicKey || ((_data$signatures = data.signatures) === null || _data$signatures === void 0 ? void 0 : _data$signatures.length) !== length) throw new Error(msg);\n      const publicKey = new PublicKey(data.publicKey);\n\n      for (let i = 0; i < length; i++) {\n        const signature = bs58.decode(data.signatures[i]);\n        allTxns[i].addSignature(publicKey, signature);\n      }\n\n      return allTxns;\n    }\n  };\n  return providerHandlers;\n};\n\nclass SlopeInjectedProxyProvider extends BaseInjectedProvider {\n  getProviderHandlers(injectedProvider) {\n    return getSlopeHandlers(injectedProvider, this.getProviderEngineProxy.bind(this));\n  }\n\n}\n\nconst getSolflareHandlers = (injectedProvider, getProviderEngineProxy) => {\n  const solflareProviderHandlers = getBaseProviderHandlers(injectedProvider);\n\n  solflareProviderHandlers.signAndSendTransaction = async req => {\n    const provider = getProviderEngineProxy();\n    if (!provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const transaction = await injectedProvider.signTransaction(req.params.message);\n    const chainConfig = await provider.request({\n      method: \"solana_provider_config\",\n      params: []\n    });\n    const conn = new Connection(chainConfig.rpcTarget);\n    const res = await conn.sendRawTransaction(transaction.serialize());\n    return {\n      signature: res\n    };\n  };\n\n  return solflareProviderHandlers;\n};\n\nclass SolflareInjectedProvider extends BaseInjectedProvider {\n  getProviderHandlers(injectedProvider) {\n    return getSolflareHandlers(injectedProvider, this.getProviderEngineProxy.bind(this));\n  }\n\n}\n\nconst getSolletHandlers = (injectedProvider, getProviderEngineProxy) => {\n  const providerHandlers = getBaseProviderHandlers(injectedProvider);\n\n  providerHandlers.signMessage = async req => {\n    const {\n      signature\n    } = await injectedProvider.sign(req.params.message, \"utf8\");\n    return signature;\n  };\n\n  providerHandlers.signAndSendTransaction = async req => {\n    const provider = getProviderEngineProxy();\n    if (!provider) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const transaction = await injectedProvider.signTransaction(req.params.message);\n    const chainConfig = await provider.request({\n      method: \"solana_provider_config\",\n      params: []\n    });\n    const conn = new Connection(chainConfig.rpcTarget);\n    const res = await conn.sendRawTransaction(transaction.serialize());\n    return {\n      signature: res\n    };\n  };\n\n  return providerHandlers;\n};\n\nclass SolletInjectedProvider extends BaseInjectedProvider {\n  getProviderHandlers(injectedProvider) {\n    return getSolletHandlers(injectedProvider, this.getProviderEngineProxy.bind(this));\n  }\n\n}\n\nconst getTorusHandlers = injectedProvider => {\n  const providerHandlers = {\n    requestAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_requestAccounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getAccounts: async () => {\n      const accounts = await injectedProvider.request({\n        method: \"solana_accounts\",\n        params: {}\n      });\n      return accounts;\n    },\n    getPrivateKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    getSecretKey: async () => {\n      throw ethErrors.rpc.methodNotSupported();\n    },\n    signMessage: async req => {\n      var _req$params;\n\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const message = await injectedProvider.signMessage(req.params.message);\n      return message;\n    },\n    signTransaction: async req => {\n      var _req$params2;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const txMessage = req.params.message;\n      const response = await injectedProvider.signTransaction(txMessage);\n      return response;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const txMessage = req.params.message;\n      const response = await injectedProvider.sendTransaction(txMessage);\n      return {\n        signature: response\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params4, _req$params5;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const transactions = req.params.message;\n      const response = await injectedProvider.signAllTransactions(transactions);\n      return response;\n    }\n  };\n  return providerHandlers;\n};\n\nfunction ownKeys$1(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread$1(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys$1(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys$1(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass TorusInjectedProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread$1(_objectSpread$1({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async switchChain(_) {\n    return Promise.resolve();\n  }\n\n  async setupProvider(injectedProvider) {\n    this.handleInjectedProviderUpdate(injectedProvider);\n    await this.setupEngine(injectedProvider);\n  }\n\n  async lookupNetwork() {\n    if (!this.provider) throw ethErrors.provider.custom({\n      message: \"Torus solana provider is not initialized\",\n      code: 4902\n    });\n    const {\n      chainId\n    } = this.config.chainConfig;\n    const connectedChainId = await this.provider.request({\n      method: \"solana_chainId\"\n    });\n    const connectedHexChainId = isHexStrict(connectedChainId.toString()) ? connectedChainId : \"0x\".concat(parseInt(connectedChainId, 10).toString(16));\n    if (chainId !== connectedHexChainId) throw WalletInitializationError.rpcConnectionError(\"Invalid network, net_version is: \".concat(connectedHexChainId, \", expected: \").concat(chainId));\n    this.update({\n      chainId: connectedHexChainId\n    });\n    this.provider.emit(\"connect\", {\n      chainId: this.state.chainId\n    });\n    this.provider.emit(\"chainChanged\", this.state.chainId);\n    return this.state.chainId;\n  }\n\n  async setupEngine(injectedProvider) {\n    const providerHandlers = getTorusHandlers(injectedProvider);\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const injectedProviderProxy = createInjectedProviderProxyMiddleware(injectedProvider);\n    const engine = new JRPCEngine();\n    engine.push(solanaMiddleware);\n    engine.push(injectedProviderProxy);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async handleInjectedProviderUpdate(injectedProvider) {\n    injectedProvider.on(\"accountsChanged\", async accounts => {\n      this.provider.emit(\"accountsChanged\", accounts);\n    });\n    injectedProvider.on(\"chainChanged\", async chainId => {\n      const connectedHexChainId = isHexStrict(chainId) ? chainId : \"0x\".concat(parseInt(chainId, 10).toString(16)); // Check if chainId changed and trigger event\n\n      this.configure({\n        chainConfig: _objectSpread$1(_objectSpread$1({}, this.config.chainConfig), {}, {\n          chainId: connectedHexChainId\n        })\n      });\n      await this.setupProvider(injectedProvider);\n    });\n  }\n\n}\n\nasync function getProviderHandlers(_ref) {\n  let {\n    privKey,\n    getProviderEngineProxy\n  } = _ref;\n\n  const keyPairGenerator = () => {\n    return Keypair.fromSecretKey(Buffer.from(privKey, \"hex\"));\n  };\n\n  if (typeof privKey !== \"string\") throw WalletInitializationError.invalidParams(\"privKey must be a string\");\n  const keyPair = keyPairGenerator();\n  const providerHandlers = {\n    requestAccounts: async () => {\n      return [keyPair.publicKey.toBase58()];\n    },\n    getAccounts: async () => [keyPair.publicKey.toBase58()],\n    getPrivateKey: async () => privKey,\n    getSecretKey: async () => bs58.encode(keyPair.secretKey),\n    signTransaction: async req => {\n      var _req$params;\n\n      if (!((_req$params = req.params) !== null && _req$params !== void 0 && _req$params.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const transaction = req.params.message;\n      transaction.partialSign(keyPair);\n      return transaction;\n    },\n    signMessage: async req => {\n      var _req$params2;\n\n      if (!((_req$params2 = req.params) !== null && _req$params2 !== void 0 && _req$params2.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const signedMsg = nacl.sign.detached(req.params.message, keyPair.secretKey);\n      return signedMsg;\n    },\n    signAndSendTransaction: async req => {\n      var _req$params3;\n\n      if (!((_req$params3 = req.params) !== null && _req$params3 !== void 0 && _req$params3.message)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const _providerEngineProxy = getProviderEngineProxy();\n\n      if (!_providerEngineProxy) throw ethErrors.provider.custom({\n        message: \"Provider is not initialized\",\n        code: 4902\n      });\n      const transaction = req.params.message;\n      transaction.sign(keyPair);\n      const sig = await _providerEngineProxy.request({\n        method: \"sendTransaction\",\n        params: [bs58.encode(transaction.serialize())]\n      });\n      return {\n        signature: sig\n      };\n    },\n    signAllTransactions: async req => {\n      var _req$params4, _req$params5, _req$params6;\n\n      if (!((_req$params4 = req.params) !== null && _req$params4 !== void 0 && _req$params4.message) || !((_req$params5 = req.params) !== null && _req$params5 !== void 0 && _req$params5.message.length)) {\n        throw ethErrors.rpc.invalidParams(\"message\");\n      }\n\n      const txns = (_req$params6 = req.params) === null || _req$params6 === void 0 ? void 0 : _req$params6.message;\n\n      for (const tx of txns || []) {\n        const transaction = tx;\n        transaction.partialSign(keyPair);\n      }\n\n      return txns;\n    }\n  };\n  return providerHandlers;\n}\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass SolanaPrivateKeyProvider extends BaseProvider {\n  constructor(_ref) {\n    let {\n      config,\n      state\n    } = _ref;\n    super({\n      config: {\n        chainConfig: _objectSpread(_objectSpread({}, config.chainConfig), {}, {\n          chainNamespace: CHAIN_NAMESPACES.SOLANA\n        })\n      },\n      state\n    });\n  }\n\n  async enable() {\n    if (!this.state.privateKey) throw ethErrors.provider.custom({\n      message: \"Private key is not found in state, plz pass it in constructor state param\",\n      code: 4902\n    });\n    await this.setupProvider(this.state.privateKey);\n    return this._providerEngineProxy.request({\n      method: \"eth_accounts\"\n    });\n  }\n\n  async setupProvider(privKey) {\n    const providerHandlers = await getProviderHandlers({\n      privKey,\n      getProviderEngineProxy: this.getProviderEngineProxy.bind(this)\n    });\n    const solanaMiddleware = createSolanaMiddleware(providerHandlers);\n    const engine = new JRPCEngine();\n    const {\n      networkMiddleware\n    } = createJsonRpcClient(this.config.chainConfig);\n    engine.push(this.getChainSwitchMiddleware());\n    engine.push(this.getAccountMiddleware());\n    engine.push(solanaMiddleware);\n    engine.push(networkMiddleware);\n    const provider = providerFromEngine(engine);\n    this.updateProviderEngineProxy(provider);\n    await this.lookupNetwork();\n  }\n\n  async updateAccount(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const existingKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n\n    if (existingKey !== params.privateKey) {\n      await this.setupProvider(params.privateKey);\n\n      this._providerEngineProxy.emit(\"accountsChanged\", {\n        accounts: await this._providerEngineProxy.request({\n          method: \"requestAccounts\"\n        })\n      });\n    }\n  }\n\n  async switchChain(params) {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const chainConfig = this.getChainConfig(params.chainId);\n    this.update({\n      chainId: \"loading\"\n    });\n    this.configure({\n      chainConfig\n    });\n    const privKey = await this._providerEngineProxy.request({\n      method: \"solanaPrivateKey\"\n    });\n    await this.setupProvider(privKey);\n  }\n\n  async lookupNetwork() {\n    if (!this._providerEngineProxy) throw ethErrors.provider.custom({\n      message: \"Provider is not initialized\",\n      code: 4902\n    });\n    const health = await this._providerEngineProxy.request({\n      method: \"getHealth\",\n      params: []\n    });\n    const {\n      chainConfig\n    } = this.config;\n    if (health !== \"ok\") throw WalletInitializationError.rpcConnectionError(\"Failed to lookup network for following rpc target: \".concat(chainConfig.rpcTarget));\n    this.update({\n      chainId: chainConfig.chainId\n    });\n\n    if (this.state.chainId !== chainConfig.chainId) {\n      this.provider.emit(\"chainChanged\", this.state.chainId);\n      this.provider.emit(\"connect\", {\n        chainId: this.state.chainId\n      });\n    }\n\n    return this.state.chainId;\n  }\n\n  getChainSwitchMiddleware() {\n    const chainSwitchHandlers = {\n      addNewChainConfig: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        const {\n          chainId,\n          chainName,\n          rpcUrls,\n          blockExplorerUrls,\n          nativeCurrency\n        } = req.params;\n        if (!chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId in chainParams\");\n        if (!rpcUrls || rpcUrls.length === 0) throw ethErrors.rpc.invalidParams(\"Missing rpcUrls in chainParams\");\n        if (!nativeCurrency) throw ethErrors.rpc.invalidParams(\"Missing nativeCurrency in chainParams\");\n        this.addChain({\n          chainNamespace: CHAIN_NAMESPACES.SOLANA,\n          chainId,\n          ticker: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.symbol) || \"SOL\",\n          tickerName: (nativeCurrency === null || nativeCurrency === void 0 ? void 0 : nativeCurrency.name) || \"Solana\",\n          displayName: chainName,\n          rpcTarget: rpcUrls[0],\n          blockExplorer: (blockExplorerUrls === null || blockExplorerUrls === void 0 ? void 0 : blockExplorerUrls[0]) || \"\"\n        });\n      },\n      switchSolanaChain: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.chainId) throw ethErrors.rpc.invalidParams(\"Missing chainId\");\n        await this.switchChain(req.params);\n      }\n    };\n    const chainSwitchMiddleware = createChainSwitchMiddleware(chainSwitchHandlers);\n    return chainSwitchMiddleware;\n  }\n\n  getAccountMiddleware() {\n    const accountHandlers = {\n      updatePrivatekey: async req => {\n        if (!req.params) throw ethErrors.rpc.invalidParams(\"Missing request params\");\n        if (!req.params.privateKey) throw ethErrors.rpc.invalidParams(\"Missing privateKey\");\n        const {\n          privateKey\n        } = req.params;\n        await this.updateAccount({\n          privateKey\n        });\n      }\n    };\n    return createAccountMiddleware(accountHandlers);\n  }\n\n}\n\n_defineProperty(SolanaPrivateKeyProvider, \"getProviderInstance\", async params => {\n  const providerFactory = new SolanaPrivateKeyProvider({\n    config: {\n      chainConfig: params.chainConfig\n    }\n  });\n  await providerFactory.setupProvider(params.privKey);\n  return providerFactory;\n});\n\nclass SolanaWallet {\n  constructor(provider) {\n    _defineProperty(this, \"provider\", void 0);\n\n    this.provider = provider;\n  }\n\n  async requestAccounts() {\n    const accounts = await this.provider.request({\n      method: \"requestAccounts\",\n      params: {}\n    });\n    return accounts;\n  }\n\n  async signAndSendTransaction(transaction) {\n    const {\n      signature\n    } = await this.provider.request({\n      method: \"signAndSendTransaction\",\n      params: {\n        message: transaction\n      }\n    });\n    return {\n      signature\n    };\n  }\n\n  async signTransaction(transaction) {\n    const signedTransaction = await this.provider.request({\n      method: \"signTransaction\",\n      params: {\n        message: transaction\n      }\n    });\n    return signedTransaction;\n  }\n\n  async signAllTransactions(transactions) {\n    const signedTransactions = await this.provider.request({\n      method: \"signAllTransactions\",\n      params: {\n        message: transactions\n      }\n    });\n    return signedTransactions;\n  }\n\n  async signMessage(data) {\n    const response = await this.provider.request({\n      method: \"signMessage\",\n      params: {\n        message: data\n      }\n    });\n    return response;\n  }\n\n  async request(args) {\n    const result = await this.provider.request(args);\n    return result;\n  }\n\n}\n\nexport { PhantomInjectedProvider, SlopeInjectedProxyProvider, SolanaPrivateKeyProvider, SolanaWallet, SolflareInjectedProvider, SolletInjectedProvider, TorusInjectedProvider };\n//# sourceMappingURL=solanaProvider.esm.js.map\n"]},"metadata":{},"sourceType":"module"}