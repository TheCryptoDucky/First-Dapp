{"ast":null,"code":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OPEN_BROADCAST_CHANNELS = exports.BroadcastChannel = void 0;\nexports.enforceOptions = enforceOptions;\n\nvar _util = require(\"./util.js\");\n\nvar _methodChooser = require(\"./method-chooser.js\");\n\nvar _options = require(\"./options.js\");\n/**\n * Contains all open channels,\n * used in tests to ensure everything is closed.\n */\n\n\nvar OPEN_BROADCAST_CHANNELS = new Set();\nexports.OPEN_BROADCAST_CHANNELS = OPEN_BROADCAST_CHANNELS;\nvar lastId = 0;\n\nvar BroadcastChannel = function BroadcastChannel(name, options) {\n  // identifier of the channel to debug stuff\n  this.id = lastId++;\n  OPEN_BROADCAST_CHANNELS.add(this);\n  this.name = name;\n\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n\n  this.options = (0, _options.fillOptionsWithDefaults)(options);\n  this.method = (0, _methodChooser.chooseMethod)(this.options); // isListening\n\n  this._iL = false;\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n\n  this._onML = null;\n  /**\n   * _addEventListeners\n   */\n\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n  /**\n   * Unsend message promises\n   * where the sending is still in progress\n   * @type {Set<Promise>}\n   */\n\n  this._uMP = new Set();\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n\n  this._befC = [];\n  /**\n   * _preparePromise\n   */\n\n  this._prepP = null;\n\n  _prepareChannel(this);\n}; // STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\n\n\nexports.BroadcastChannel = BroadcastChannel;\nBroadcastChannel._pubkey = true;\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */\n\nvar ENFORCED_OPTIONS;\n\nfunction enforceOptions(options) {\n  ENFORCED_OPTIONS = options;\n} // PROTOTYPE\n\n\nBroadcastChannel.prototype = {\n  postMessage: function postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed ' +\n      /**\n       * In the past when this error appeared, it was realy hard to debug.\n       * So now we log the msg together with the error so it at least\n       * gives some clue about where in your application this happens.\n       */\n      JSON.stringify(msg));\n    }\n\n    return _post(this, 'message', msg);\n  },\n  postInternal: function postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n\n  set onmessage(fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _removeListenerObject(this, 'message', this._onML);\n\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n\n  addEventListener: function addEventListener(type, fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener: function removeEventListener(type, fn) {\n    var obj = this._addEL[type].find(function (obj) {\n      return obj.fn === fn;\n    });\n\n    _removeListenerObject(this, type, obj);\n  },\n  close: function close() {\n    var _this = this;\n\n    if (this.closed) {\n      return;\n    }\n\n    OPEN_BROADCAST_CHANNELS[\"delete\"](this);\n    this.closed = true;\n    var awaitPrepare = this._prepP ? this._prepP : _util.PROMISE_RESOLVED_VOID;\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare // wait until all current sending are processed\n    .then(function () {\n      return Promise.all(Array.from(_this._uMP));\n    }) // run before-close hooks\n    .then(function () {\n      return Promise.all(_this._befC.map(function (fn) {\n        return fn();\n      }));\n    }) // close the channel\n    .then(function () {\n      return _this.method.close(_this._state);\n    });\n  },\n\n  get type() {\n    return this.method.type;\n  },\n\n  get isClosed() {\n    return this.closed;\n  }\n\n};\n/**\n * Post a message over the channel\n * @returns {Promise} that resolved when the message sending is done\n */\n\nfunction _post(broadcastChannel, type, msg) {\n  var time = broadcastChannel.method.microSeconds();\n  var msgObj = {\n    time: time,\n    type: type,\n    data: msg\n  };\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : _util.PROMISE_RESOLVED_VOID;\n  return awaitPrepare.then(function () {\n    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj); // add/remove to unsend messages list\n\n    broadcastChannel._uMP.add(sendPromise);\n\n    sendPromise[\"catch\"]().then(function () {\n      return broadcastChannel._uMP[\"delete\"](sendPromise);\n    });\n    return sendPromise;\n  });\n}\n\nfunction _prepareChannel(channel) {\n  var maybePromise = channel.method.create(channel.name, channel.options);\n\n  if ((0, _util.isPromise)(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(function (s) {\n      // used in tests to simulate slow runtime\n\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\n\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\n\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n\n  _startListening(channel);\n}\n\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\n    return o !== obj;\n  });\n\n  _stopListening(channel);\n}\n\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n    var listenerFn = function listenerFn(msgObj) {\n      channel._addEL[msgObj.type].forEach(function (listenerObject) {\n        /**\n         * Getting the current time in JavaScript has no good precision.\n         * So instead of only listening to events that happend 'after' the listener\n         * was added, we also listen to events that happended 100ms before it.\n         * This ensures that when another process, like a WebWorker, sends events\n         * we do not miss them out because their timestamp is a bit off compared to the main process.\n         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.\n         * @link https://johnresig.com/blog/accuracy-of-javascript-time/\n         */\n        var hundredMsInMicro = 100 * 1000;\n        var minMessageTime = listenerObject.time - hundredMsInMicro;\n\n        if (msgObj.time >= minMessageTime) {\n          listenerObject.fn(msgObj.data);\n        } else if (channel.method.type === 'server') {\n          // server msg might lag based on connection.\n          listenerObject.fn(msgObj.data);\n        }\n      });\n    };\n\n    var time = channel.method.microSeconds();\n\n    if (channel._prepP) {\n      channel._prepP.then(function () {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\n\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // noone is listening, stop subscribing\n    channel._iL = false;\n    var time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}","map":{"version":3,"names":["Object","defineProperty","exports","value","OPEN_BROADCAST_CHANNELS","BroadcastChannel","enforceOptions","_util","require","_methodChooser","_options","Set","lastId","name","options","id","add","ENFORCED_OPTIONS","fillOptionsWithDefaults","method","chooseMethod","_iL","_onML","_addEL","message","internal","_uMP","_befC","_prepP","_prepareChannel","_pubkey","prototype","postMessage","msg","closed","Error","JSON","stringify","_post","postInternal","onmessage","fn","time","microSeconds","listenObj","_removeListenerObject","_addListenerObject","addEventListener","type","removeEventListener","obj","find","close","_this","awaitPrepare","PROMISE_RESOLVED_VOID","then","Promise","all","Array","from","map","_state","isClosed","broadcastChannel","msgObj","data","sendPromise","channel","maybePromise","create","isPromise","s","_hasMessageListeners","length","push","_startListening","filter","o","_stopListening","listenerFn","forEach","listenerObject","hundredMsInMicro","minMessageTime","onMessage"],"sources":["C:/Users/crypt/Desktop/Sentiment Dapp/FirstDapp-Starter/node_modules/@toruslabs/solana-embed/node_modules/@toruslabs/broadcast-channel/dist/lib/broadcast-channel.js"],"sourcesContent":["\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.OPEN_BROADCAST_CHANNELS = exports.BroadcastChannel = void 0;\nexports.enforceOptions = enforceOptions;\n\nvar _util = require(\"./util.js\");\n\nvar _methodChooser = require(\"./method-chooser.js\");\n\nvar _options = require(\"./options.js\");\n\n/**\n * Contains all open channels,\n * used in tests to ensure everything is closed.\n */\nvar OPEN_BROADCAST_CHANNELS = new Set();\nexports.OPEN_BROADCAST_CHANNELS = OPEN_BROADCAST_CHANNELS;\nvar lastId = 0;\n\nvar BroadcastChannel = function BroadcastChannel(name, options) {\n  // identifier of the channel to debug stuff\n  this.id = lastId++;\n  OPEN_BROADCAST_CHANNELS.add(this);\n  this.name = name;\n\n  if (ENFORCED_OPTIONS) {\n    options = ENFORCED_OPTIONS;\n  }\n\n  this.options = (0, _options.fillOptionsWithDefaults)(options);\n  this.method = (0, _methodChooser.chooseMethod)(this.options); // isListening\n\n  this._iL = false;\n  /**\n   * _onMessageListener\n   * setting onmessage twice,\n   * will overwrite the first listener\n   */\n\n  this._onML = null;\n  /**\n   * _addEventListeners\n   */\n\n  this._addEL = {\n    message: [],\n    internal: []\n  };\n  /**\n   * Unsend message promises\n   * where the sending is still in progress\n   * @type {Set<Promise>}\n   */\n\n  this._uMP = new Set();\n  /**\n   * _beforeClose\n   * array of promises that will be awaited\n   * before the channel is closed\n   */\n\n  this._befC = [];\n  /**\n   * _preparePromise\n   */\n\n  this._prepP = null;\n\n  _prepareChannel(this);\n}; // STATICS\n\n/**\n * used to identify if someone overwrites\n * window.BroadcastChannel with this\n * See methods/native.js\n */\n\n\nexports.BroadcastChannel = BroadcastChannel;\nBroadcastChannel._pubkey = true;\n/**\n * if set, this method is enforced,\n * no mather what the options are\n */\n\nvar ENFORCED_OPTIONS;\n\nfunction enforceOptions(options) {\n  ENFORCED_OPTIONS = options;\n} // PROTOTYPE\n\n\nBroadcastChannel.prototype = {\n  postMessage: function postMessage(msg) {\n    if (this.closed) {\n      throw new Error('BroadcastChannel.postMessage(): ' + 'Cannot post message after channel has closed ' +\n      /**\n       * In the past when this error appeared, it was realy hard to debug.\n       * So now we log the msg together with the error so it at least\n       * gives some clue about where in your application this happens.\n       */\n      JSON.stringify(msg));\n    }\n\n    return _post(this, 'message', msg);\n  },\n  postInternal: function postInternal(msg) {\n    return _post(this, 'internal', msg);\n  },\n\n  set onmessage(fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _removeListenerObject(this, 'message', this._onML);\n\n    if (fn && typeof fn === 'function') {\n      this._onML = listenObj;\n\n      _addListenerObject(this, 'message', listenObj);\n    } else {\n      this._onML = null;\n    }\n  },\n\n  addEventListener: function addEventListener(type, fn) {\n    var time = this.method.microSeconds();\n    var listenObj = {\n      time: time,\n      fn: fn\n    };\n\n    _addListenerObject(this, type, listenObj);\n  },\n  removeEventListener: function removeEventListener(type, fn) {\n    var obj = this._addEL[type].find(function (obj) {\n      return obj.fn === fn;\n    });\n\n    _removeListenerObject(this, type, obj);\n  },\n  close: function close() {\n    var _this = this;\n\n    if (this.closed) {\n      return;\n    }\n\n    OPEN_BROADCAST_CHANNELS[\"delete\"](this);\n    this.closed = true;\n    var awaitPrepare = this._prepP ? this._prepP : _util.PROMISE_RESOLVED_VOID;\n    this._onML = null;\n    this._addEL.message = [];\n    return awaitPrepare // wait until all current sending are processed\n    .then(function () {\n      return Promise.all(Array.from(_this._uMP));\n    }) // run before-close hooks\n    .then(function () {\n      return Promise.all(_this._befC.map(function (fn) {\n        return fn();\n      }));\n    }) // close the channel\n    .then(function () {\n      return _this.method.close(_this._state);\n    });\n  },\n\n  get type() {\n    return this.method.type;\n  },\n\n  get isClosed() {\n    return this.closed;\n  }\n\n};\n/**\n * Post a message over the channel\n * @returns {Promise} that resolved when the message sending is done\n */\n\nfunction _post(broadcastChannel, type, msg) {\n  var time = broadcastChannel.method.microSeconds();\n  var msgObj = {\n    time: time,\n    type: type,\n    data: msg\n  };\n  var awaitPrepare = broadcastChannel._prepP ? broadcastChannel._prepP : _util.PROMISE_RESOLVED_VOID;\n  return awaitPrepare.then(function () {\n    var sendPromise = broadcastChannel.method.postMessage(broadcastChannel._state, msgObj); // add/remove to unsend messages list\n\n    broadcastChannel._uMP.add(sendPromise);\n\n    sendPromise[\"catch\"]().then(function () {\n      return broadcastChannel._uMP[\"delete\"](sendPromise);\n    });\n    return sendPromise;\n  });\n}\n\nfunction _prepareChannel(channel) {\n  var maybePromise = channel.method.create(channel.name, channel.options);\n\n  if ((0, _util.isPromise)(maybePromise)) {\n    channel._prepP = maybePromise;\n    maybePromise.then(function (s) {\n      // used in tests to simulate slow runtime\n\n      /*if (channel.options.prepareDelay) {\n           await new Promise(res => setTimeout(res, this.options.prepareDelay));\n      }*/\n      channel._state = s;\n    });\n  } else {\n    channel._state = maybePromise;\n  }\n}\n\nfunction _hasMessageListeners(channel) {\n  if (channel._addEL.message.length > 0) return true;\n  if (channel._addEL.internal.length > 0) return true;\n  return false;\n}\n\nfunction _addListenerObject(channel, type, obj) {\n  channel._addEL[type].push(obj);\n\n  _startListening(channel);\n}\n\nfunction _removeListenerObject(channel, type, obj) {\n  channel._addEL[type] = channel._addEL[type].filter(function (o) {\n    return o !== obj;\n  });\n\n  _stopListening(channel);\n}\n\nfunction _startListening(channel) {\n  if (!channel._iL && _hasMessageListeners(channel)) {\n    // someone is listening, start subscribing\n    var listenerFn = function listenerFn(msgObj) {\n      channel._addEL[msgObj.type].forEach(function (listenerObject) {\n        /**\n         * Getting the current time in JavaScript has no good precision.\n         * So instead of only listening to events that happend 'after' the listener\n         * was added, we also listen to events that happended 100ms before it.\n         * This ensures that when another process, like a WebWorker, sends events\n         * we do not miss them out because their timestamp is a bit off compared to the main process.\n         * Not doing this would make messages missing when we send data directly after subscribing and awaiting a response.\n         * @link https://johnresig.com/blog/accuracy-of-javascript-time/\n         */\n        var hundredMsInMicro = 100 * 1000;\n        var minMessageTime = listenerObject.time - hundredMsInMicro;\n\n        if (msgObj.time >= minMessageTime) {\n          listenerObject.fn(msgObj.data);\n        } else if (channel.method.type === 'server') {\n          // server msg might lag based on connection.\n          listenerObject.fn(msgObj.data);\n        }\n      });\n    };\n\n    var time = channel.method.microSeconds();\n\n    if (channel._prepP) {\n      channel._prepP.then(function () {\n        channel._iL = true;\n        channel.method.onMessage(channel._state, listenerFn, time);\n      });\n    } else {\n      channel._iL = true;\n      channel.method.onMessage(channel._state, listenerFn, time);\n    }\n  }\n}\n\nfunction _stopListening(channel) {\n  if (channel._iL && !_hasMessageListeners(channel)) {\n    // noone is listening, stop subscribing\n    channel._iL = false;\n    var time = channel.method.microSeconds();\n    channel.method.onMessage(channel._state, null, time);\n  }\n}"],"mappings":"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"},"metadata":{},"sourceType":"script"}