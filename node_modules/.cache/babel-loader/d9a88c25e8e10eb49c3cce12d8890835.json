{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { SafeEventEmitter } from '@toruslabs/openlogin-jrpc';\nimport { ADAPTER_STATUS, log, CHAIN_NAMESPACES, WalletInitializationError, storageAvailable, getChainConfig, ADAPTER_NAMESPACES, WalletLoginError, ADAPTER_EVENTS } from '@web3auth/base';\nimport { PLUGIN_NAMESPACES } from '@web3auth/base-plugin';\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nconst ADAPTER_CACHE_KEY = \"Web3Auth-cachedAdapter\";\n\nclass Web3AuthCore extends SafeEventEmitter {\n  constructor(options) {\n    var _options$chainConfig, _options$chainConfig2, _options$chainConfig3, _options$chainConfig4;\n\n    super();\n\n    _defineProperty(this, \"coreOptions\", void 0);\n\n    _defineProperty(this, \"connectedAdapterName\", null);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"cachedAdapter\", null);\n\n    _defineProperty(this, \"walletAdapters\", {});\n\n    _defineProperty(this, \"plugins\", {});\n\n    _defineProperty(this, \"storage\", \"localStorage\");\n\n    if (options.enableLogging) log.enableAll();else log.disableAll();\n    if (!((_options$chainConfig = options.chainConfig) !== null && _options$chainConfig !== void 0 && _options$chainConfig.chainNamespace) || !Object.values(CHAIN_NAMESPACES).includes((_options$chainConfig2 = options.chainConfig) === null || _options$chainConfig2 === void 0 ? void 0 : _options$chainConfig2.chainNamespace)) throw WalletInitializationError.invalidParams(\"Please provide a valid chainNamespace in chainConfig\");\n    if (options.storageKey === \"session\") this.storage = \"sessionStorage\";\n    this.cachedAdapter = storageAvailable(this.storage) ? window[this.storage].getItem(ADAPTER_CACHE_KEY) : null;\n    this.coreOptions = _objectSpread(_objectSpread({}, options), {}, {\n      chainConfig: _objectSpread(_objectSpread({}, getChainConfig((_options$chainConfig3 = options.chainConfig) === null || _options$chainConfig3 === void 0 ? void 0 : _options$chainConfig3.chainNamespace, (_options$chainConfig4 = options.chainConfig) === null || _options$chainConfig4 === void 0 ? void 0 : _options$chainConfig4.chainId) || {}), options.chainConfig)\n    });\n    this.subscribeToAdapterEvents = this.subscribeToAdapterEvents.bind(this);\n  }\n\n  get provider() {\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName) {\n      const adapter = this.walletAdapters[this.connectedAdapterName];\n      return adapter.provider;\n    }\n\n    return null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init() {\n    const initPromises = Object.keys(this.walletAdapters).map(adapterName => {\n      this.subscribeToAdapterEvents(this.walletAdapters[adapterName]); // if adapter doesn't have any chain config yet thn set it based on provided namespace and chainId.\n      // if no chainNamespace or chainId is being provided, it will connect with mainnet.\n\n      if (!this.walletAdapters[adapterName].chainConfigProxy) {\n        const providedChainConfig = this.coreOptions.chainConfig;\n        if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n\n        const chainConfig = _objectSpread(_objectSpread({}, getChainConfig(providedChainConfig.chainNamespace, providedChainConfig.chainId)), providedChainConfig);\n\n        this.walletAdapters[adapterName].setChainConfig(chainConfig);\n      }\n\n      return this.walletAdapters[adapterName].init({\n        autoConnect: this.cachedAdapter === adapterName\n      }).catch(e => log.error(e));\n    });\n    this.status = ADAPTER_STATUS.READY;\n    await Promise.all(initPromises);\n  }\n\n  configureAdapter(adapter) {\n    this.checkInitRequirements();\n    const providedChainConfig = this.coreOptions.chainConfig;\n    if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n    const adapterAlreadyExists = this.walletAdapters[adapter.name];\n    if (adapterAlreadyExists) throw WalletInitializationError.duplicateAdapterError(\"Wallet adapter for \".concat(adapter.name, \" already exists\"));\n    if (adapter.adapterNamespace !== ADAPTER_NAMESPACES.MULTICHAIN && adapter.adapterNamespace !== providedChainConfig.chainNamespace) throw WalletInitializationError.incompatibleChainNameSpace(\"This wallet adapter belongs to \".concat(adapter.adapterNamespace, \" which is incompatible with currently used namespace: \").concat(providedChainConfig.chainNamespace));\n\n    if (adapter.adapterNamespace === ADAPTER_NAMESPACES.MULTICHAIN && adapter.currentChainNamespace && providedChainConfig.chainNamespace !== adapter.currentChainNamespace) {\n      // chainConfig checks are already validated in constructor so using typecast is safe here.\n      adapter.setChainConfig(providedChainConfig);\n    }\n\n    this.walletAdapters[adapter.name] = adapter;\n    return this;\n  }\n\n  clearCache() {\n    if (!storageAvailable(this.storage)) return;\n    window[this.storage].removeItem(ADAPTER_CACHE_KEY);\n    this.cachedAdapter = null;\n  }\n  /**\n   * Connect to a specific wallet adapter\n   * @param walletName - Key of the walletAdapter to use.\n   */\n\n\n  async connectTo(walletName, loginParams) {\n    if (!this.walletAdapters[walletName]) throw WalletInitializationError.notFound(\"Please add wallet adapter for \".concat(walletName, \" wallet, before connecting\"));\n    const provider = await this.walletAdapters[walletName].connect(loginParams);\n    return provider;\n  }\n\n  async logout() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(\"No wallet is connected\");\n    await this.walletAdapters[this.connectedAdapterName].disconnect(options);\n  }\n\n  async getUserInfo() {\n    log.debug(\"Getting user info\", this.status, this.connectedAdapterName);\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(\"No wallet is connected\");\n    return this.walletAdapters[this.connectedAdapterName].getUserInfo();\n  }\n\n  async addPlugin(plugin) {\n    if (this.plugins[plugin.name]) throw new Error(\"Plugin \".concat(plugin.name, \" already exist\"));\n    if (plugin.pluginNamespace !== PLUGIN_NAMESPACES.MULTICHAIN && plugin.pluginNamespace !== this.coreOptions.chainConfig.chainNamespace) throw new Error(\"This plugin belongs to \".concat(plugin.pluginNamespace, \" namespace which is incompatible with currently used namespace: \").concat(this.coreOptions.chainConfig.chainNamespace));\n    this.plugins[plugin.name] = plugin;\n    await plugin.initWithWeb3Auth(this);\n    return this;\n  }\n\n  subscribeToAdapterEvents(walletAdapter) {\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTED, async data => {\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.connectedAdapterName = data.adapter;\n      this.cacheWallet(data.adapter);\n      log.debug(\"connected\", this.status, this.connectedAdapterName);\n      await Promise.all(Object.values(this.plugins).map(plugin => {\n        return plugin.connect().catch(error => {\n          // swallow error if connector adapter doesn't supports this plugin.\n          if (error.code === 5211) {\n            return;\n          } // throw error;\n\n\n          log.error(error);\n        });\n      }));\n      this.emit(ADAPTER_EVENTS.CONNECTED, _objectSpread({}, data));\n    });\n    walletAdapter.on(ADAPTER_EVENTS.DISCONNECTED, async data => {\n      // get back to ready state for rehydrating.\n      this.status = ADAPTER_STATUS.READY;\n\n      if (storageAvailable(this.storage)) {\n        const cachedAdapter = window[this.storage].getItem(ADAPTER_CACHE_KEY);\n\n        if (this.connectedAdapterName === cachedAdapter) {\n          this.clearCache();\n        }\n      }\n\n      log.debug(\"disconnected\", this.status, this.connectedAdapterName);\n      await Promise.all(Object.values(this.plugins).map(plugin => {\n        return plugin.disconnect().catch(error => {\n          // swallow error if adapter doesn't supports this plugin.\n          if (error.code === 5211) {\n            return;\n          } // throw error;\n\n\n          log.error(error);\n        });\n      }));\n      this.connectedAdapterName = null;\n      this.emit(ADAPTER_EVENTS.DISCONNECTED, data);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTING, data => {\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, data);\n      log.debug(\"connecting\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ERRORED, data => {\n      this.status = ADAPTER_STATUS.ERRORED;\n      this.clearCache();\n      this.emit(ADAPTER_EVENTS.ERRORED, data);\n      log.debug(\"errored\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data => {\n      log.debug(\"adapter data updated\", data);\n      this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data);\n    });\n  }\n\n  checkInitRequirements() {\n    if (this.status === ADAPTER_STATUS.CONNECTING) throw WalletInitializationError.notReady(\"Already pending connection\");\n    if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletInitializationError.notReady(\"Already connected\");\n    if (this.status === ADAPTER_STATUS.READY) throw WalletInitializationError.notReady(\"Adapter is already initialized\");\n  }\n\n  cacheWallet(walletName) {\n    if (!storageAvailable(this.storage)) return;\n    window[this.storage].setItem(ADAPTER_CACHE_KEY, walletName);\n    this.cachedAdapter = walletName;\n  }\n\n}\n\nexport { Web3AuthCore };","map":{"version":3,"sources":["../src/core.ts"],"names":["ADAPTER_CACHE_KEY","ADAPTER_STATUS","NOT_READY","constructor","options","log","Object","WalletInitializationError","storageAvailable","window","chainConfig","getChainConfig","chainNamespace","provider","adapter","init","initPromises","adapterName","providedChainConfig","autoConnect","e","Promise","configureAdapter","adapterAlreadyExists","ADAPTER_NAMESPACES","clearCache","connectTo","logout","cleanup","WalletLoginError","getUserInfo","addPlugin","plugin","PLUGIN_NAMESPACES","subscribeToAdapterEvents","walletAdapter","ADAPTER_EVENTS","data","error","cachedAdapter","checkInitRequirements","cacheWallet"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { SafeEventEmitter } from '@toruslabs/openlogin-jrpc';\nimport { ADAPTER_STATUS, log, CHAIN_NAMESPACES, WalletInitializationError, storageAvailable, getChainConfig, ADAPTER_NAMESPACES, WalletLoginError, ADAPTER_EVENTS } from '@web3auth/base';\nimport { PLUGIN_NAMESPACES } from '@web3auth/base-plugin';\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nconst ADAPTER_CACHE_KEY = \"Web3Auth-cachedAdapter\";\nclass Web3AuthCore extends SafeEventEmitter {\n  constructor(options) {\n    var _options$chainConfig, _options$chainConfig2, _options$chainConfig3, _options$chainConfig4;\n\n    super();\n\n    _defineProperty(this, \"coreOptions\", void 0);\n\n    _defineProperty(this, \"connectedAdapterName\", null);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"cachedAdapter\", null);\n\n    _defineProperty(this, \"walletAdapters\", {});\n\n    _defineProperty(this, \"plugins\", {});\n\n    _defineProperty(this, \"storage\", \"localStorage\");\n\n    if (options.enableLogging) log.enableAll();else log.disableAll();\n    if (!((_options$chainConfig = options.chainConfig) !== null && _options$chainConfig !== void 0 && _options$chainConfig.chainNamespace) || !Object.values(CHAIN_NAMESPACES).includes((_options$chainConfig2 = options.chainConfig) === null || _options$chainConfig2 === void 0 ? void 0 : _options$chainConfig2.chainNamespace)) throw WalletInitializationError.invalidParams(\"Please provide a valid chainNamespace in chainConfig\");\n    if (options.storageKey === \"session\") this.storage = \"sessionStorage\";\n    this.cachedAdapter = storageAvailable(this.storage) ? window[this.storage].getItem(ADAPTER_CACHE_KEY) : null;\n    this.coreOptions = _objectSpread(_objectSpread({}, options), {}, {\n      chainConfig: _objectSpread(_objectSpread({}, getChainConfig((_options$chainConfig3 = options.chainConfig) === null || _options$chainConfig3 === void 0 ? void 0 : _options$chainConfig3.chainNamespace, (_options$chainConfig4 = options.chainConfig) === null || _options$chainConfig4 === void 0 ? void 0 : _options$chainConfig4.chainId) || {}), options.chainConfig)\n    });\n    this.subscribeToAdapterEvents = this.subscribeToAdapterEvents.bind(this);\n  }\n\n  get provider() {\n    if (this.status === ADAPTER_STATUS.CONNECTED && this.connectedAdapterName) {\n      const adapter = this.walletAdapters[this.connectedAdapterName];\n      return adapter.provider;\n    }\n\n    return null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init() {\n    const initPromises = Object.keys(this.walletAdapters).map(adapterName => {\n      this.subscribeToAdapterEvents(this.walletAdapters[adapterName]); // if adapter doesn't have any chain config yet thn set it based on provided namespace and chainId.\n      // if no chainNamespace or chainId is being provided, it will connect with mainnet.\n\n      if (!this.walletAdapters[adapterName].chainConfigProxy) {\n        const providedChainConfig = this.coreOptions.chainConfig;\n        if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n\n        const chainConfig = _objectSpread(_objectSpread({}, getChainConfig(providedChainConfig.chainNamespace, providedChainConfig.chainId)), providedChainConfig);\n\n        this.walletAdapters[adapterName].setChainConfig(chainConfig);\n      }\n\n      return this.walletAdapters[adapterName].init({\n        autoConnect: this.cachedAdapter === adapterName\n      }).catch(e => log.error(e));\n    });\n    this.status = ADAPTER_STATUS.READY;\n    await Promise.all(initPromises);\n  }\n\n  configureAdapter(adapter) {\n    this.checkInitRequirements();\n    const providedChainConfig = this.coreOptions.chainConfig;\n    if (!providedChainConfig.chainNamespace) throw WalletInitializationError.invalidParams(\"Please provide chainNamespace in chainConfig\");\n    const adapterAlreadyExists = this.walletAdapters[adapter.name];\n    if (adapterAlreadyExists) throw WalletInitializationError.duplicateAdapterError(\"Wallet adapter for \".concat(adapter.name, \" already exists\"));\n    if (adapter.adapterNamespace !== ADAPTER_NAMESPACES.MULTICHAIN && adapter.adapterNamespace !== providedChainConfig.chainNamespace) throw WalletInitializationError.incompatibleChainNameSpace(\"This wallet adapter belongs to \".concat(adapter.adapterNamespace, \" which is incompatible with currently used namespace: \").concat(providedChainConfig.chainNamespace));\n\n    if (adapter.adapterNamespace === ADAPTER_NAMESPACES.MULTICHAIN && adapter.currentChainNamespace && providedChainConfig.chainNamespace !== adapter.currentChainNamespace) {\n      // chainConfig checks are already validated in constructor so using typecast is safe here.\n      adapter.setChainConfig(providedChainConfig);\n    }\n\n    this.walletAdapters[adapter.name] = adapter;\n    return this;\n  }\n\n  clearCache() {\n    if (!storageAvailable(this.storage)) return;\n    window[this.storage].removeItem(ADAPTER_CACHE_KEY);\n    this.cachedAdapter = null;\n  }\n  /**\n   * Connect to a specific wallet adapter\n   * @param walletName - Key of the walletAdapter to use.\n   */\n\n\n  async connectTo(walletName, loginParams) {\n    if (!this.walletAdapters[walletName]) throw WalletInitializationError.notFound(\"Please add wallet adapter for \".concat(walletName, \" wallet, before connecting\"));\n    const provider = await this.walletAdapters[walletName].connect(loginParams);\n    return provider;\n  }\n\n  async logout() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(\"No wallet is connected\");\n    await this.walletAdapters[this.connectedAdapterName].disconnect(options);\n  }\n\n  async getUserInfo() {\n    log.debug(\"Getting user info\", this.status, this.connectedAdapterName);\n    if (this.status !== ADAPTER_STATUS.CONNECTED || !this.connectedAdapterName) throw WalletLoginError.notConnectedError(\"No wallet is connected\");\n    return this.walletAdapters[this.connectedAdapterName].getUserInfo();\n  }\n\n  async addPlugin(plugin) {\n    if (this.plugins[plugin.name]) throw new Error(\"Plugin \".concat(plugin.name, \" already exist\"));\n    if (plugin.pluginNamespace !== PLUGIN_NAMESPACES.MULTICHAIN && plugin.pluginNamespace !== this.coreOptions.chainConfig.chainNamespace) throw new Error(\"This plugin belongs to \".concat(plugin.pluginNamespace, \" namespace which is incompatible with currently used namespace: \").concat(this.coreOptions.chainConfig.chainNamespace));\n    this.plugins[plugin.name] = plugin;\n    await plugin.initWithWeb3Auth(this);\n    return this;\n  }\n\n  subscribeToAdapterEvents(walletAdapter) {\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTED, async data => {\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.connectedAdapterName = data.adapter;\n      this.cacheWallet(data.adapter);\n      log.debug(\"connected\", this.status, this.connectedAdapterName);\n      await Promise.all(Object.values(this.plugins).map(plugin => {\n        return plugin.connect().catch(error => {\n          // swallow error if connector adapter doesn't supports this plugin.\n          if (error.code === 5211) {\n            return;\n          } // throw error;\n\n\n          log.error(error);\n        });\n      }));\n      this.emit(ADAPTER_EVENTS.CONNECTED, _objectSpread({}, data));\n    });\n    walletAdapter.on(ADAPTER_EVENTS.DISCONNECTED, async data => {\n      // get back to ready state for rehydrating.\n      this.status = ADAPTER_STATUS.READY;\n\n      if (storageAvailable(this.storage)) {\n        const cachedAdapter = window[this.storage].getItem(ADAPTER_CACHE_KEY);\n\n        if (this.connectedAdapterName === cachedAdapter) {\n          this.clearCache();\n        }\n      }\n\n      log.debug(\"disconnected\", this.status, this.connectedAdapterName);\n      await Promise.all(Object.values(this.plugins).map(plugin => {\n        return plugin.disconnect().catch(error => {\n          // swallow error if adapter doesn't supports this plugin.\n          if (error.code === 5211) {\n            return;\n          } // throw error;\n\n\n          log.error(error);\n        });\n      }));\n      this.connectedAdapterName = null;\n      this.emit(ADAPTER_EVENTS.DISCONNECTED, data);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.CONNECTING, data => {\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, data);\n      log.debug(\"connecting\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ERRORED, data => {\n      this.status = ADAPTER_STATUS.ERRORED;\n      this.clearCache();\n      this.emit(ADAPTER_EVENTS.ERRORED, data);\n      log.debug(\"errored\", this.status, this.connectedAdapterName);\n    });\n    walletAdapter.on(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data => {\n      log.debug(\"adapter data updated\", data);\n      this.emit(ADAPTER_EVENTS.ADAPTER_DATA_UPDATED, data);\n    });\n  }\n\n  checkInitRequirements() {\n    if (this.status === ADAPTER_STATUS.CONNECTING) throw WalletInitializationError.notReady(\"Already pending connection\");\n    if (this.status === ADAPTER_STATUS.CONNECTED) throw WalletInitializationError.notReady(\"Already connected\");\n    if (this.status === ADAPTER_STATUS.READY) throw WalletInitializationError.notReady(\"Adapter is already initialized\");\n  }\n\n  cacheWallet(walletName) {\n    if (!storageAvailable(this.storage)) return;\n    window[this.storage].setItem(ADAPTER_CACHE_KEY, walletName);\n    this.cachedAdapter = walletName;\n  }\n\n}\n\nexport { Web3AuthCore };\n//# sourceMappingURL=core.esm.js.map\n"]},"metadata":{},"sourceType":"module"}