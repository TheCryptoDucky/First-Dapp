{"ast":null,"code":"import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport WalletConnect from '@walletconnect/client';\nimport { CHAIN_NAMESPACES, BaseAdapter, WALLET_ADAPTERS, ADAPTER_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, getChainConfig, ADAPTER_EVENTS, log, WalletInitializationError, Web3AuthError, WalletLoginError } from '@web3auth/base';\nimport { WalletConnectProvider } from '@web3auth/ethereum-provider';\nconst WALLET_CONNECT_EXTENSION_ADAPTERS = [{\n  name: \"Rainbow\",\n  chains: [CHAIN_NAMESPACES.EIP155],\n  logo: \"https://images.web3auth.io/login-rainbow.svg\",\n  mobile: {\n    native: \"rainbow:\",\n    universal: \"https://rnbwapp.com\"\n  },\n  desktop: {\n    native: \"\",\n    universal: \"\"\n  }\n}, {\n  name: \"MetaMask\",\n  chains: [CHAIN_NAMESPACES.EIP155],\n  logo: \"https://images.web3auth.io/login-metamask.svg\",\n  mobile: {\n    native: \"metamask:\",\n    universal: \"https://metamask.app.link\"\n  },\n  desktop: {\n    native: \"\",\n    universal: \"\"\n  }\n}];\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass WalletConnectV1Adapter extends BaseAdapter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.WALLET_CONNECT_V1);\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\n\n    _defineProperty(this, \"adapterOptions\", void 0);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"adapterData\", {\n      uri: \"\",\n      extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS\n    });\n\n    _defineProperty(this, \"connector\", null);\n\n    _defineProperty(this, \"wcProvider\", null);\n\n    _defineProperty(this, \"rehydrated\", false);\n\n    this.adapterOptions = _objectSpread({}, options);\n    this.chainConfig = options.chainConfig || null;\n  }\n\n  get connected() {\n    var _this$connector;\n\n    return !!((_this$connector = this.connector) !== null && _this$connector !== void 0 && _this$connector.connected);\n  }\n\n  get provider() {\n    var _this$wcProvider;\n\n    return ((_this$wcProvider = this.wcProvider) === null || _this$wcProvider === void 0 ? void 0 : _this$wcProvider.provider) || null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init() {\n    super.checkInitializationRequirements();\n\n    if (!this.chainConfig) {\n      this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);\n    } // Create a connector\n\n\n    this.connector = this.getWalletConnectInstance();\n    this.wcProvider = new WalletConnectProvider({\n      config: {\n        chainConfig: this.chainConfig\n      },\n      connector: this.connector\n    });\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n    this.status = ADAPTER_STATUS.READY;\n    log.debug(\"initializing wallet connect v1 adapter\");\n\n    if (this.connector.connected) {\n      this.rehydrated = true;\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId\n      });\n    }\n  }\n\n  async connect() {\n    super.checkConnectionRequirements();\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n    if (this.connected) {\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId\n      });\n      return this.provider;\n    }\n\n    if (this.status !== ADAPTER_STATUS.CONNECTING) {\n      var _this$adapterOptions$; // for wallet connect qr code modal we have to create a new connector, coz wallet connect internally does not open\n      // modal again on existing instance if connection is pending.\n\n\n      if ((_this$adapterOptions$ = this.adapterOptions.adapterSettings) !== null && _this$adapterOptions$ !== void 0 && _this$adapterOptions$.qrcodeModal) {\n        var _this$adapterOptions$2;\n\n        this.connector = this.getWalletConnectInstance();\n        this.wcProvider = new WalletConnectProvider({\n          config: {\n            chainConfig: this.chainConfig,\n            // network switching can be skipped with custom ui\n            skipLookupNetwork: (_this$adapterOptions$2 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$2 === void 0 ? void 0 : _this$adapterOptions$2.skipNetworkSwitching\n          },\n          connector: this.connector\n        });\n      }\n\n      await this.createNewSession();\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, {\n        adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\")); // for wallet connect default modal.\n\n      this.connector.on(\"modal_closed\", async () => {\n        this.status = ADAPTER_STATUS.READY;\n        this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n        return reject(new Error(\"User closed modal\"));\n      });\n\n      try {\n        // Subscribe to session connection\n        this.connector.on(\"connect\", async (error, payload) => {\n          if (error) {\n            this.emit(ADAPTER_EVENTS.ERRORED, error);\n          }\n\n          log.debug(\"connected event emitted by web3auth\");\n          await this.onConnectHandler(payload.params[0]);\n          return resolve(this.provider);\n        });\n      } catch (error) {\n        log.error(\"Wallet connect v1 adapter error while connecting\", error); // ready again to be connected\n\n        this.status = ADAPTER_STATUS.READY;\n        this.rehydrated = true;\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        reject(error instanceof Web3AuthError ? error : WalletLoginError.connectionError(\"Failed to login with wallet connect: \".concat((error === null || error === void 0 ? void 0 : error.message) || \"\")));\n      }\n    });\n  }\n\n  async getUserInfo() {\n    if (!this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    const {\n      cleanup\n    } = options;\n    if (!this.connector || !this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    await this.connector.killSession();\n    this.rehydrated = false;\n\n    if (cleanup) {\n      this.connector = null;\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.wcProvider = null;\n    } else {\n      // ready to connect again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async addChain(chainConfig) {\n    try {\n      var _this$adapterOptions$3;\n\n      if (!this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n      const networkSwitch = (_this$adapterOptions$3 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$3 === void 0 ? void 0 : _this$adapterOptions$3.networkSwitchModal;\n\n      if (networkSwitch) {\n        await networkSwitch.addNetwork({\n          chainConfig,\n          appOrigin: window.location.hostname\n        });\n      }\n\n      await this.wcProvider.addChain(chainConfig);\n    } catch (error) {\n      log.error(error);\n    }\n  }\n\n  async switchChain(connectedChainConfig, chainConfig) {\n    var _this$adapterOptions$4;\n\n    if (!this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    const networkSwitch = (_this$adapterOptions$4 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$4 === void 0 ? void 0 : _this$adapterOptions$4.networkSwitchModal;\n\n    if (networkSwitch) {\n      await networkSwitch.switchNetwork({\n        currentChainConfig: chainConfig,\n        newChainConfig: connectedChainConfig,\n        appOrigin: window.location.hostname\n      });\n    }\n\n    await this.wcProvider.switchChain({\n      chainId: chainConfig.chainId,\n      lookup: false,\n      addChain: false\n    });\n  }\n\n  async createNewSession() {\n    var _this$adapterOptions, _this$adapterOptions$5;\n\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      forceNewSession: false\n    };\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n    if (opts.forceNewSession && this.connector.pending) {\n      await this.connector.killSession();\n    } // for wallet connect qr modal\n\n\n    if ((_this$adapterOptions = this.adapterOptions) !== null && _this$adapterOptions !== void 0 && (_this$adapterOptions$5 = _this$adapterOptions.adapterSettings) !== null && _this$adapterOptions$5 !== void 0 && _this$adapterOptions$5.qrcodeModal) {\n      var _this$chainConfig;\n\n      await this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig = this.chainConfig) === null || _this$chainConfig === void 0 ? void 0 : _this$chainConfig.chainId) || \"0x1\", 16)\n      });\n      return;\n    } // for web3auth qr code modal\n\n\n    return new Promise((resolve, reject) => {\n      var _this$chainConfig2;\n\n      if (!this.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\"));\n      log.debug(\"creating new session for web3auth wallet connect\");\n      this.connector.on(\"display_uri\", async (err, payload) => {\n        var _this$connector2;\n\n        if (err) {\n          this.emit(ADAPTER_EVENTS.ERRORED, WalletLoginError.connectionError(\"Failed to display wallet connect qr code\"));\n          return reject(err);\n        }\n\n        const uri = payload.params[0];\n        this.updateAdapterData({\n          uri,\n          extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS\n        });\n        (_this$connector2 = this.connector) === null || _this$connector2 === void 0 ? void 0 : _this$connector2.off(\"display_uri\");\n        return resolve();\n      });\n      this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig2 = this.chainConfig) === null || _this$chainConfig2 === void 0 ? void 0 : _this$chainConfig2.chainId) || \"0x1\", 16)\n      }).catch(error => {\n        log.error(\"error while creating new wallet connect session\", error);\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        return reject(error);\n      });\n    });\n  }\n\n  async onConnectHandler(params) {\n    if (!this.connector || !this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"Chain config is not set\");\n    const {\n      chainId\n    } = params;\n    log.debug(\"connected chainId in hex\");\n\n    if (chainId !== parseInt(this.chainConfig.chainId, 16)) {\n      var _this$adapterOptions$6, _this$adapterOptions2, _this$adapterOptions3;\n\n      const connectedChainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, chainId) || {\n        chainId: \"0x\".concat(chainId.toString(16)),\n        displayName: \"Unknown Network\"\n      };\n      const isCustomUi = (_this$adapterOptions$6 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$6 === void 0 ? void 0 : _this$adapterOptions$6.qrcodeModal; // skipping network is not allowed in default ui. We are use network switching modal for default ui.\n\n      if (!isCustomUi || isCustomUi && !((_this$adapterOptions2 = this.adapterOptions) !== null && _this$adapterOptions2 !== void 0 && (_this$adapterOptions3 = _this$adapterOptions2.adapterSettings) !== null && _this$adapterOptions3 !== void 0 && _this$adapterOptions3.skipNetworkSwitching)) {\n        try {\n          await this.addChain(this.chainConfig);\n          await this.switchChain(connectedChainConfig, this.chainConfig);\n          this.connector = this.getWalletConnectInstance();\n        } catch (error) {\n          log.error(\"error while chain switching\", error); // we need to create a new session since old session is already used and\n          // user needs to login again with correct chain with new qr code.\n\n          await this.createNewSession({\n            forceNewSession: true\n          });\n          this.emit(ADAPTER_EVENTS.ERRORED, WalletInitializationError.fromCode(5000, \"Not connected to correct network. Expected: \".concat(this.chainConfig.displayName, \", Current: \").concat((connectedChainConfig === null || connectedChainConfig === void 0 ? void 0 : connectedChainConfig.displayName) || chainId, \", Please switch to correct network from wallet\")));\n          this.status = ADAPTER_STATUS.READY;\n          this.rehydrated = true;\n          return;\n        }\n      }\n    }\n\n    await this.wcProvider.setupProvider(this.connector);\n    this.subscribeEvents(this.connector);\n    this.status = ADAPTER_STATUS.CONNECTED;\n    this.emit(ADAPTER_EVENTS.CONNECTED, {\n      adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1,\n      reconnected: this.rehydrated\n    });\n  }\n\n  subscribeEvents(connector) {\n    connector.on(\"session_update\", async error => {\n      if (error) {\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n      }\n    });\n  }\n\n  getWalletConnectInstance() {\n    const walletConnectOptions = this.adapterOptions.adapterSettings || {};\n    walletConnectOptions.bridge = walletConnectOptions.bridge || \"https://bridge.walletconnect.org\"; // Create a connector\n\n    return new WalletConnect(walletConnectOptions);\n  }\n\n}\n\nexport { WalletConnectV1Adapter };","map":{"version":3,"sources":["../src/config.ts","../src/walletConnectV1adapter.ts"],"names":["WALLET_CONNECT_EXTENSION_ADAPTERS","name","chains","CHAIN_NAMESPACES","logo","mobile","native","universal","desktop","WALLET_ADAPTERS","WALLET_CONNECT_V1","ADAPTER_NAMESPACES","EIP155","ADAPTER_CATEGORY","EXTERNAL","ADAPTER_STATUS","NOT_READY","uri","extensionAdapters","constructor","options","connected","provider","wcProvider","init","getChainConfig","config","chainConfig","connector","ADAPTER_EVENTS","log","accounts","chainId","connect","WalletInitializationError","skipLookupNetwork","skipNetworkSwitching","adapter","reject","payload","resolve","error","WalletLoginError","getUserInfo","disconnect","cleanup","addChain","networkSwitch","appOrigin","window","hostname","switchChain","currentChainConfig","newChainConfig","lookup","createNewSession","opts","forceNewSession","parseInt","onConnectHandler","connectedChainConfig","displayName","isCustomUi","reconnected","rehydrated","subscribeEvents","getWalletConnectInstance","walletConnectOptions"],"mappings":"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","sourcesContent":["import _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport WalletConnect from '@walletconnect/client';\nimport { CHAIN_NAMESPACES, BaseAdapter, WALLET_ADAPTERS, ADAPTER_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, getChainConfig, ADAPTER_EVENTS, log, WalletInitializationError, Web3AuthError, WalletLoginError } from '@web3auth/base';\nimport { WalletConnectProvider } from '@web3auth/ethereum-provider';\n\nconst WALLET_CONNECT_EXTENSION_ADAPTERS = [{\n  name: \"Rainbow\",\n  chains: [CHAIN_NAMESPACES.EIP155],\n  logo: \"https://images.web3auth.io/login-rainbow.svg\",\n  mobile: {\n    native: \"rainbow:\",\n    universal: \"https://rnbwapp.com\"\n  },\n  desktop: {\n    native: \"\",\n    universal: \"\"\n  }\n}, {\n  name: \"MetaMask\",\n  chains: [CHAIN_NAMESPACES.EIP155],\n  logo: \"https://images.web3auth.io/login-metamask.svg\",\n  mobile: {\n    native: \"metamask:\",\n    universal: \"https://metamask.app.link\"\n  },\n  desktop: {\n    native: \"\",\n    universal: \"\"\n  }\n}];\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\n\nclass WalletConnectV1Adapter extends BaseAdapter {\n  constructor() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n    super();\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.WALLET_CONNECT_V1);\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.EXTERNAL);\n\n    _defineProperty(this, \"adapterOptions\", void 0);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"adapterData\", {\n      uri: \"\",\n      extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS\n    });\n\n    _defineProperty(this, \"connector\", null);\n\n    _defineProperty(this, \"wcProvider\", null);\n\n    _defineProperty(this, \"rehydrated\", false);\n\n    this.adapterOptions = _objectSpread({}, options);\n    this.chainConfig = options.chainConfig || null;\n  }\n\n  get connected() {\n    var _this$connector;\n\n    return !!((_this$connector = this.connector) !== null && _this$connector !== void 0 && _this$connector.connected);\n  }\n\n  get provider() {\n    var _this$wcProvider;\n\n    return ((_this$wcProvider = this.wcProvider) === null || _this$wcProvider === void 0 ? void 0 : _this$wcProvider.provider) || null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init() {\n    super.checkInitializationRequirements();\n\n    if (!this.chainConfig) {\n      this.chainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, 1);\n    } // Create a connector\n\n\n    this.connector = this.getWalletConnectInstance();\n    this.wcProvider = new WalletConnectProvider({\n      config: {\n        chainConfig: this.chainConfig\n      },\n      connector: this.connector\n    });\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n    this.status = ADAPTER_STATUS.READY;\n    log.debug(\"initializing wallet connect v1 adapter\");\n\n    if (this.connector.connected) {\n      this.rehydrated = true;\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId\n      });\n    }\n  }\n\n  async connect() {\n    super.checkConnectionRequirements();\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n    if (this.connected) {\n      await this.onConnectHandler({\n        accounts: this.connector.accounts,\n        chainId: this.connector.chainId\n      });\n      return this.provider;\n    }\n\n    if (this.status !== ADAPTER_STATUS.CONNECTING) {\n      var _this$adapterOptions$;\n\n      // for wallet connect qr code modal we have to create a new connector, coz wallet connect internally does not open\n      // modal again on existing instance if connection is pending.\n      if ((_this$adapterOptions$ = this.adapterOptions.adapterSettings) !== null && _this$adapterOptions$ !== void 0 && _this$adapterOptions$.qrcodeModal) {\n        var _this$adapterOptions$2;\n\n        this.connector = this.getWalletConnectInstance();\n        this.wcProvider = new WalletConnectProvider({\n          config: {\n            chainConfig: this.chainConfig,\n            // network switching can be skipped with custom ui\n            skipLookupNetwork: (_this$adapterOptions$2 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$2 === void 0 ? void 0 : _this$adapterOptions$2.skipNetworkSwitching\n          },\n          connector: this.connector\n        });\n      }\n\n      await this.createNewSession();\n      this.status = ADAPTER_STATUS.CONNECTING;\n      this.emit(ADAPTER_EVENTS.CONNECTING, {\n        adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1\n      });\n    }\n\n    return new Promise((resolve, reject) => {\n      if (!this.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\")); // for wallet connect default modal.\n\n      this.connector.on(\"modal_closed\", async () => {\n        this.status = ADAPTER_STATUS.READY;\n        this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.WALLET_CONNECT_V1);\n        return reject(new Error(\"User closed modal\"));\n      });\n\n      try {\n        // Subscribe to session connection\n        this.connector.on(\"connect\", async (error, payload) => {\n          if (error) {\n            this.emit(ADAPTER_EVENTS.ERRORED, error);\n          }\n\n          log.debug(\"connected event emitted by web3auth\");\n          await this.onConnectHandler(payload.params[0]);\n          return resolve(this.provider);\n        });\n      } catch (error) {\n        log.error(\"Wallet connect v1 adapter error while connecting\", error); // ready again to be connected\n\n        this.status = ADAPTER_STATUS.READY;\n        this.rehydrated = true;\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        reject(error instanceof Web3AuthError ? error : WalletLoginError.connectionError(\"Failed to login with wallet connect: \".concat((error === null || error === void 0 ? void 0 : error.message) || \"\")));\n      }\n    });\n  }\n\n  async getUserInfo() {\n    if (!this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet, Please login/connect first\");\n    return {};\n  }\n\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    const {\n      cleanup\n    } = options;\n    if (!this.connector || !this.connected) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    await this.connector.killSession();\n    this.rehydrated = false;\n\n    if (cleanup) {\n      this.connector = null;\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.wcProvider = null;\n    } else {\n      // ready to connect again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async addChain(chainConfig) {\n    try {\n      var _this$adapterOptions$3;\n\n      if (!this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n      const networkSwitch = (_this$adapterOptions$3 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$3 === void 0 ? void 0 : _this$adapterOptions$3.networkSwitchModal;\n\n      if (networkSwitch) {\n        await networkSwitch.addNetwork({\n          chainConfig,\n          appOrigin: window.location.hostname\n        });\n      }\n\n      await this.wcProvider.addChain(chainConfig);\n    } catch (error) {\n      log.error(error);\n    }\n  }\n\n  async switchChain(connectedChainConfig, chainConfig) {\n    var _this$adapterOptions$4;\n\n    if (!this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    const networkSwitch = (_this$adapterOptions$4 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$4 === void 0 ? void 0 : _this$adapterOptions$4.networkSwitchModal;\n\n    if (networkSwitch) {\n      await networkSwitch.switchNetwork({\n        currentChainConfig: chainConfig,\n        newChainConfig: connectedChainConfig,\n        appOrigin: window.location.hostname\n      });\n    }\n\n    await this.wcProvider.switchChain({\n      chainId: chainConfig.chainId,\n      lookup: false,\n      addChain: false\n    });\n  }\n\n  async createNewSession() {\n    var _this$adapterOptions, _this$adapterOptions$5;\n\n    let opts = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      forceNewSession: false\n    };\n    if (!this.connector) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n\n    if (opts.forceNewSession && this.connector.pending) {\n      await this.connector.killSession();\n    } // for wallet connect qr modal\n\n\n    if ((_this$adapterOptions = this.adapterOptions) !== null && _this$adapterOptions !== void 0 && (_this$adapterOptions$5 = _this$adapterOptions.adapterSettings) !== null && _this$adapterOptions$5 !== void 0 && _this$adapterOptions$5.qrcodeModal) {\n      var _this$chainConfig;\n\n      await this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig = this.chainConfig) === null || _this$chainConfig === void 0 ? void 0 : _this$chainConfig.chainId) || \"0x1\", 16)\n      });\n      return;\n    } // for web3auth qr code modal\n\n\n    return new Promise((resolve, reject) => {\n      var _this$chainConfig2;\n\n      if (!this.connector) return reject(WalletInitializationError.notReady(\"Wallet adapter is not ready yet\"));\n      log.debug(\"creating new session for web3auth wallet connect\");\n      this.connector.on(\"display_uri\", async (err, payload) => {\n        var _this$connector2;\n\n        if (err) {\n          this.emit(ADAPTER_EVENTS.ERRORED, WalletLoginError.connectionError(\"Failed to display wallet connect qr code\"));\n          return reject(err);\n        }\n\n        const uri = payload.params[0];\n        this.updateAdapterData({\n          uri,\n          extensionAdapters: WALLET_CONNECT_EXTENSION_ADAPTERS\n        });\n        (_this$connector2 = this.connector) === null || _this$connector2 === void 0 ? void 0 : _this$connector2.off(\"display_uri\");\n        return resolve();\n      });\n      this.connector.createSession({\n        chainId: parseInt(((_this$chainConfig2 = this.chainConfig) === null || _this$chainConfig2 === void 0 ? void 0 : _this$chainConfig2.chainId) || \"0x1\", 16)\n      }).catch(error => {\n        log.error(\"error while creating new wallet connect session\", error);\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n        return reject(error);\n      });\n    });\n  }\n\n  async onConnectHandler(params) {\n    if (!this.connector || !this.wcProvider) throw WalletInitializationError.notReady(\"Wallet adapter is not ready yet\");\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"Chain config is not set\");\n    const {\n      chainId\n    } = params;\n    log.debug(\"connected chainId in hex\");\n\n    if (chainId !== parseInt(this.chainConfig.chainId, 16)) {\n      var _this$adapterOptions$6, _this$adapterOptions2, _this$adapterOptions3;\n\n      const connectedChainConfig = getChainConfig(CHAIN_NAMESPACES.EIP155, chainId) || {\n        chainId: \"0x\".concat(chainId.toString(16)),\n        displayName: \"Unknown Network\"\n      };\n      const isCustomUi = (_this$adapterOptions$6 = this.adapterOptions.adapterSettings) === null || _this$adapterOptions$6 === void 0 ? void 0 : _this$adapterOptions$6.qrcodeModal; // skipping network is not allowed in default ui. We are use network switching modal for default ui.\n\n      if (!isCustomUi || isCustomUi && !((_this$adapterOptions2 = this.adapterOptions) !== null && _this$adapterOptions2 !== void 0 && (_this$adapterOptions3 = _this$adapterOptions2.adapterSettings) !== null && _this$adapterOptions3 !== void 0 && _this$adapterOptions3.skipNetworkSwitching)) {\n        try {\n          await this.addChain(this.chainConfig);\n          await this.switchChain(connectedChainConfig, this.chainConfig);\n          this.connector = this.getWalletConnectInstance();\n        } catch (error) {\n          log.error(\"error while chain switching\", error); // we need to create a new session since old session is already used and\n          // user needs to login again with correct chain with new qr code.\n\n          await this.createNewSession({\n            forceNewSession: true\n          });\n          this.emit(ADAPTER_EVENTS.ERRORED, WalletInitializationError.fromCode(5000, \"Not connected to correct network. Expected: \".concat(this.chainConfig.displayName, \", Current: \").concat((connectedChainConfig === null || connectedChainConfig === void 0 ? void 0 : connectedChainConfig.displayName) || chainId, \", Please switch to correct network from wallet\")));\n          this.status = ADAPTER_STATUS.READY;\n          this.rehydrated = true;\n          return;\n        }\n      }\n    }\n\n    await this.wcProvider.setupProvider(this.connector);\n    this.subscribeEvents(this.connector);\n    this.status = ADAPTER_STATUS.CONNECTED;\n    this.emit(ADAPTER_EVENTS.CONNECTED, {\n      adapter: WALLET_ADAPTERS.WALLET_CONNECT_V1,\n      reconnected: this.rehydrated\n    });\n  }\n\n  subscribeEvents(connector) {\n    connector.on(\"session_update\", async error => {\n      if (error) {\n        this.emit(ADAPTER_EVENTS.ERRORED, error);\n      }\n    });\n  }\n\n  getWalletConnectInstance() {\n    const walletConnectOptions = this.adapterOptions.adapterSettings || {};\n    walletConnectOptions.bridge = walletConnectOptions.bridge || \"https://bridge.walletconnect.org\"; // Create a connector\n\n    return new WalletConnect(walletConnectOptions);\n  }\n\n}\n\nexport { WalletConnectV1Adapter };\n//# sourceMappingURL=walletConnectV1Adapter.esm.js.map\n"]},"metadata":{},"sourceType":"module"}