{"ast":null,"code":"import OpenLogin, { OPENLOGIN_NETWORK, UX_MODE, getHashQueryParams } from '@toruslabs/openlogin';\nimport { getChainConfig, BaseAdapter, WALLET_ADAPTERS, ADAPTER_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, CHAIN_NAMESPACES, log, WalletInitializationError, ADAPTER_EVENTS, WalletLoginError } from '@web3auth/base';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { CommonPrivateKeyProvider } from '@web3auth/base-provider';\nimport merge from 'lodash.merge';\n\nconst getOpenloginDefaultOptions = (chainNamespace, chainId) => {\n  return {\n    adapterSettings: {\n      network: OPENLOGIN_NETWORK.MAINNET,\n      clientId: \"\",\n      uxMode: UX_MODE.POPUP\n    },\n    chainConfig: chainNamespace ? getChainConfig(chainNamespace, chainId) : null,\n    loginSettings: {\n      relogin: true\n    }\n  };\n};\n\nfunction ownKeys(object, enumerableOnly) {\n  var keys = Object.keys(object);\n\n  if (Object.getOwnPropertySymbols) {\n    var symbols = Object.getOwnPropertySymbols(object);\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n    })), keys.push.apply(keys, symbols);\n  }\n\n  return keys;\n}\n\nfunction _objectSpread(target) {\n  for (var i = 1; i < arguments.length; i++) {\n    var source = null != arguments[i] ? arguments[i] : {};\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\n      _defineProperty(target, key, source[key]);\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n    });\n  }\n\n  return target;\n}\n\nclass OpenloginAdapter extends BaseAdapter {\n  constructor(params) {\n    var _params$chainConfig, _params$chainConfig2, _params$chainConfig3;\n\n    super();\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.OPENLOGIN);\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.MULTICHAIN);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.IN_APP);\n\n    _defineProperty(this, \"openloginInstance\", null);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"openloginOptions\", void 0);\n\n    _defineProperty(this, \"loginSettings\", {});\n\n    _defineProperty(this, \"privKeyProvider\", null);\n\n    log.debug(\"const openlogin adapter\", params);\n    const defaultOptions = getOpenloginDefaultOptions((_params$chainConfig = params.chainConfig) === null || _params$chainConfig === void 0 ? void 0 : _params$chainConfig.chainNamespace, (_params$chainConfig2 = params.chainConfig) === null || _params$chainConfig2 === void 0 ? void 0 : _params$chainConfig2.chainId);\n    this.openloginOptions = _objectSpread(_objectSpread({\n      clientId: \"\",\n      network: OPENLOGIN_NETWORK.MAINNET\n    }, defaultOptions.adapterSettings), params.adapterSettings || {});\n    this.loginSettings = _objectSpread(_objectSpread({}, defaultOptions.loginSettings), params.loginSettings); // if no chainNamespace is passed then chain config should be set before calling init\n\n    if ((_params$chainConfig3 = params.chainConfig) !== null && _params$chainConfig3 !== void 0 && _params$chainConfig3.chainNamespace) {\n      var _params$chainConfig4;\n\n      this.currentChainNamespace = (_params$chainConfig4 = params.chainConfig) === null || _params$chainConfig4 === void 0 ? void 0 : _params$chainConfig4.chainNamespace;\n      const defaultChainIdConfig = defaultOptions.chainConfig ? defaultOptions.chainConfig : {};\n      this.chainConfig = _objectSpread(_objectSpread({}, defaultChainIdConfig), params === null || params === void 0 ? void 0 : params.chainConfig);\n      log.debug(\"const openlogin chainConfig\", this.chainConfig);\n\n      if (!this.chainConfig.rpcTarget) {\n        throw WalletInitializationError.invalidParams(\"rpcTarget is required in chainConfig\");\n      }\n    }\n  }\n\n  get chainConfigProxy() {\n    return this.chainConfig ? _objectSpread({}, this.chainConfig) : null;\n  }\n\n  get provider() {\n    var _this$privKeyProvider;\n\n    return ((_this$privKeyProvider = this.privKeyProvider) === null || _this$privKeyProvider === void 0 ? void 0 : _this$privKeyProvider.provider) || null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init(options) {\n    var _this$openloginOption;\n\n    super.checkInitializationRequirements();\n    if (!((_this$openloginOption = this.openloginOptions) !== null && _this$openloginOption !== void 0 && _this$openloginOption.clientId)) throw WalletInitializationError.invalidParams(\"clientId is required before openlogin's initialization\");\n    if (!this.chainConfig && this.currentChainNamespace !== CHAIN_NAMESPACES.OTHER) throw WalletInitializationError.invalidParams(\"chainConfig is required before initialization\");\n    let isRedirectResult = false;\n\n    if (this.openloginOptions.uxMode === UX_MODE.REDIRECT) {\n      const redirectResult = getHashQueryParams();\n\n      if (Object.keys(redirectResult).length > 0 && redirectResult._pid) {\n        isRedirectResult = true;\n      }\n    }\n\n    this.openloginOptions = _objectSpread(_objectSpread({}, this.openloginOptions), {}, {\n      replaceUrlOnRedirect: isRedirectResult\n    });\n    this.openloginInstance = new OpenLogin(this.openloginOptions);\n    log.debug(\"initializing openlogin adapter init\");\n    await this.openloginInstance.init();\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.OPENLOGIN);\n\n    try {\n      log.debug(\"initializing openlogin adapter\"); // connect only if it is redirect result or if connect (adapter is cached/already connected in same session) is true\n\n      if (this.openloginInstance.privKey && (options.autoConnect || isRedirectResult)) {\n        await this.connect();\n      }\n    } catch (error) {\n      log.error(\"Failed to connect with cached openlogin provider\", error);\n      this.emit(\"ERRORED\", error);\n    }\n  }\n\n  async connect(params) {\n    super.checkConnectionRequirements();\n    this.status = ADAPTER_STATUS.CONNECTING;\n    this.emit(ADAPTER_EVENTS.CONNECTING, _objectSpread(_objectSpread({}, params), {}, {\n      adapter: WALLET_ADAPTERS.OPENLOGIN\n    }));\n\n    try {\n      await this.connectWithProvider(params);\n      return this.provider;\n    } catch (error) {\n      log.error(\"Failed to connect with openlogin provider\", error); // ready again to be connected\n\n      this.status = ADAPTER_STATUS.READY;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n\n      if (error !== null && error !== void 0 && error.message.includes(\"user closed popup\")) {\n        throw WalletLoginError.popupClosed();\n      }\n\n      throw WalletLoginError.connectionError(\"Failed to login with openlogin\");\n    }\n  }\n\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    await this.openloginInstance.logout();\n\n    if (options.cleanup) {\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.openloginInstance = null;\n      this.privKeyProvider = null;\n    } else {\n      // ready to be connected again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async getUserInfo() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    const userInfo = await this.openloginInstance.getUserInfo();\n    return userInfo;\n  } // should be called only before initialization.\n\n\n  setAdapterSettings(adapterSettings) {\n    if (this.status === ADAPTER_STATUS.READY) return;\n    const defaultOptions = getOpenloginDefaultOptions();\n    this.openloginOptions = _objectSpread(_objectSpread(_objectSpread({}, defaultOptions.adapterSettings), this.openloginOptions || {}), adapterSettings);\n  } // should be called only before initialization.\n\n\n  setChainConfig(customChainConfig) {\n    super.setChainConfig(customChainConfig);\n    this.currentChainNamespace = customChainConfig.chainNamespace;\n  }\n\n  async connectWithProvider(params) {\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"chainConfig is required before initialization\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n\n    if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n      const {\n        SolanaPrivateKeyProvider\n      } = await import('@web3auth/solana-provider');\n      this.privKeyProvider = new SolanaPrivateKeyProvider({\n        config: {\n          chainConfig: this.chainConfig\n        }\n      });\n    } else if (this.currentChainNamespace === CHAIN_NAMESPACES.EIP155) {\n      const {\n        EthereumPrivateKeyProvider\n      } = await import('@web3auth/ethereum-provider');\n      this.privKeyProvider = new EthereumPrivateKeyProvider({\n        config: {\n          chainConfig: this.chainConfig\n        }\n      });\n    } else if (this.currentChainNamespace === CHAIN_NAMESPACES.OTHER) {\n      this.privKeyProvider = new CommonPrivateKeyProvider();\n    } else {\n      throw new Error(\"Invalid chainNamespace: \".concat(this.currentChainNamespace, \" found while connecting to wallet\"));\n    } // if not logged in then login\n\n\n    if (!this.openloginInstance.privKey && params) {\n      var _params$extraLoginOpt;\n\n      await this.openloginInstance.login(merge(this.loginSettings, {\n        loginProvider: params.loginProvider\n      }, {\n        extraLoginOptions: _objectSpread(_objectSpread({}, params.extraLoginOptions || {}), {}, {\n          login_hint: params.login_hint || ((_params$extraLoginOpt = params.extraLoginOptions) === null || _params$extraLoginOpt === void 0 ? void 0 : _params$extraLoginOpt.login_hint)\n        })\n      }));\n    }\n\n    let finalPrivKey = this.openloginInstance.privKey;\n\n    if (finalPrivKey) {\n      if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n        const {\n          getED25519Key\n        } = await import('@toruslabs/openlogin-ed25519');\n        finalPrivKey = getED25519Key(finalPrivKey).sk.toString(\"hex\");\n      }\n\n      await this.privKeyProvider.setupProvider(finalPrivKey);\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.emit(ADAPTER_EVENTS.CONNECTED, {\n        adapter: WALLET_ADAPTERS.OPENLOGIN,\n        reconnected: !params\n      });\n    }\n  }\n\n}\n\nexport { OpenloginAdapter, getOpenloginDefaultOptions };","map":{"version":3,"sources":["../src/config.ts","../src/openloginAdapter.ts"],"names":["getOpenloginDefaultOptions","adapterSettings","network","OPENLOGIN_NETWORK","clientId","uxMode","UX_MODE","POPUP","chainConfig","chainNamespace","getChainConfig","loginSettings","relogin","WALLET_ADAPTERS","OPENLOGIN","ADAPTER_NAMESPACES","MULTICHAIN","ADAPTER_CATEGORY","IN_APP","ADAPTER_STATUS","NOT_READY","CHAIN_NAMESPACES","EIP155","constructor","log","defaultOptions","params","MAINNET","defaultChainIdConfig","WalletInitializationError","chainConfigProxy","provider","privKeyProvider","init","isRedirectResult","redirectResult","getHashQueryParams","Object","replaceUrlOnRedirect","ADAPTER_EVENTS","options","connect","adapter","error","WalletLoginError","disconnect","cleanup","getUserInfo","userInfo","setAdapterSettings","setChainConfig","customChainConfig","connectWithProvider","SolanaPrivateKeyProvider","config","EthereumPrivateKeyProvider","merge","loginProvider","extraLoginOptions","login_hint","finalPrivKey","getED25519Key","reconnected"],"mappings":"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","sourcesContent":["import OpenLogin, { OPENLOGIN_NETWORK, UX_MODE, getHashQueryParams } from '@toruslabs/openlogin';\nimport { getChainConfig, BaseAdapter, WALLET_ADAPTERS, ADAPTER_NAMESPACES, ADAPTER_CATEGORY, ADAPTER_STATUS, CHAIN_NAMESPACES, log, WalletInitializationError, ADAPTER_EVENTS, WalletLoginError } from '@web3auth/base';\nimport _defineProperty from '@babel/runtime/helpers/defineProperty';\nimport { CommonPrivateKeyProvider } from '@web3auth/base-provider';\nimport merge from 'lodash.merge';\n\nconst getOpenloginDefaultOptions = (chainNamespace, chainId) => {\n  return {\n    adapterSettings: {\n      network: OPENLOGIN_NETWORK.MAINNET,\n      clientId: \"\",\n      uxMode: UX_MODE.POPUP\n    },\n    chainConfig: chainNamespace ? getChainConfig(chainNamespace, chainId) : null,\n    loginSettings: {\n      relogin: true\n    }\n  };\n};\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); enumerableOnly && (symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; })), keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = null != arguments[i] ? arguments[i] : {}; i % 2 ? ownKeys(Object(source), !0).forEach(function (key) { _defineProperty(target, key, source[key]); }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } return target; }\nclass OpenloginAdapter extends BaseAdapter {\n  constructor(params) {\n    var _params$chainConfig, _params$chainConfig2, _params$chainConfig3;\n\n    super();\n\n    _defineProperty(this, \"name\", WALLET_ADAPTERS.OPENLOGIN);\n\n    _defineProperty(this, \"adapterNamespace\", ADAPTER_NAMESPACES.MULTICHAIN);\n\n    _defineProperty(this, \"type\", ADAPTER_CATEGORY.IN_APP);\n\n    _defineProperty(this, \"openloginInstance\", null);\n\n    _defineProperty(this, \"status\", ADAPTER_STATUS.NOT_READY);\n\n    _defineProperty(this, \"currentChainNamespace\", CHAIN_NAMESPACES.EIP155);\n\n    _defineProperty(this, \"openloginOptions\", void 0);\n\n    _defineProperty(this, \"loginSettings\", {});\n\n    _defineProperty(this, \"privKeyProvider\", null);\n\n    log.debug(\"const openlogin adapter\", params);\n    const defaultOptions = getOpenloginDefaultOptions((_params$chainConfig = params.chainConfig) === null || _params$chainConfig === void 0 ? void 0 : _params$chainConfig.chainNamespace, (_params$chainConfig2 = params.chainConfig) === null || _params$chainConfig2 === void 0 ? void 0 : _params$chainConfig2.chainId);\n    this.openloginOptions = _objectSpread(_objectSpread({\n      clientId: \"\",\n      network: OPENLOGIN_NETWORK.MAINNET\n    }, defaultOptions.adapterSettings), params.adapterSettings || {});\n    this.loginSettings = _objectSpread(_objectSpread({}, defaultOptions.loginSettings), params.loginSettings); // if no chainNamespace is passed then chain config should be set before calling init\n\n    if ((_params$chainConfig3 = params.chainConfig) !== null && _params$chainConfig3 !== void 0 && _params$chainConfig3.chainNamespace) {\n      var _params$chainConfig4;\n\n      this.currentChainNamespace = (_params$chainConfig4 = params.chainConfig) === null || _params$chainConfig4 === void 0 ? void 0 : _params$chainConfig4.chainNamespace;\n      const defaultChainIdConfig = defaultOptions.chainConfig ? defaultOptions.chainConfig : {};\n      this.chainConfig = _objectSpread(_objectSpread({}, defaultChainIdConfig), params === null || params === void 0 ? void 0 : params.chainConfig);\n      log.debug(\"const openlogin chainConfig\", this.chainConfig);\n\n      if (!this.chainConfig.rpcTarget) {\n        throw WalletInitializationError.invalidParams(\"rpcTarget is required in chainConfig\");\n      }\n    }\n  }\n\n  get chainConfigProxy() {\n    return this.chainConfig ? _objectSpread({}, this.chainConfig) : null;\n  }\n\n  get provider() {\n    var _this$privKeyProvider;\n\n    return ((_this$privKeyProvider = this.privKeyProvider) === null || _this$privKeyProvider === void 0 ? void 0 : _this$privKeyProvider.provider) || null;\n  }\n\n  set provider(_) {\n    throw new Error(\"Not implemented\");\n  }\n\n  async init(options) {\n    var _this$openloginOption;\n\n    super.checkInitializationRequirements();\n    if (!((_this$openloginOption = this.openloginOptions) !== null && _this$openloginOption !== void 0 && _this$openloginOption.clientId)) throw WalletInitializationError.invalidParams(\"clientId is required before openlogin's initialization\");\n    if (!this.chainConfig && this.currentChainNamespace !== CHAIN_NAMESPACES.OTHER) throw WalletInitializationError.invalidParams(\"chainConfig is required before initialization\");\n    let isRedirectResult = false;\n\n    if (this.openloginOptions.uxMode === UX_MODE.REDIRECT) {\n      const redirectResult = getHashQueryParams();\n\n      if (Object.keys(redirectResult).length > 0 && redirectResult._pid) {\n        isRedirectResult = true;\n      }\n    }\n\n    this.openloginOptions = _objectSpread(_objectSpread({}, this.openloginOptions), {}, {\n      replaceUrlOnRedirect: isRedirectResult\n    });\n    this.openloginInstance = new OpenLogin(this.openloginOptions);\n    log.debug(\"initializing openlogin adapter init\");\n    await this.openloginInstance.init();\n    this.status = ADAPTER_STATUS.READY;\n    this.emit(ADAPTER_EVENTS.READY, WALLET_ADAPTERS.OPENLOGIN);\n\n    try {\n      log.debug(\"initializing openlogin adapter\"); // connect only if it is redirect result or if connect (adapter is cached/already connected in same session) is true\n\n      if (this.openloginInstance.privKey && (options.autoConnect || isRedirectResult)) {\n        await this.connect();\n      }\n    } catch (error) {\n      log.error(\"Failed to connect with cached openlogin provider\", error);\n      this.emit(\"ERRORED\", error);\n    }\n  }\n\n  async connect(params) {\n    super.checkConnectionRequirements();\n    this.status = ADAPTER_STATUS.CONNECTING;\n    this.emit(ADAPTER_EVENTS.CONNECTING, _objectSpread(_objectSpread({}, params), {}, {\n      adapter: WALLET_ADAPTERS.OPENLOGIN\n    }));\n\n    try {\n      await this.connectWithProvider(params);\n      return this.provider;\n    } catch (error) {\n      log.error(\"Failed to connect with openlogin provider\", error); // ready again to be connected\n\n      this.status = ADAPTER_STATUS.READY;\n      this.emit(ADAPTER_EVENTS.ERRORED, error);\n\n      if (error !== null && error !== void 0 && error.message.includes(\"user closed popup\")) {\n        throw WalletLoginError.popupClosed();\n      }\n\n      throw WalletLoginError.connectionError(\"Failed to login with openlogin\");\n    }\n  }\n\n  async disconnect() {\n    let options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {\n      cleanup: false\n    };\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    await this.openloginInstance.logout();\n\n    if (options.cleanup) {\n      this.status = ADAPTER_STATUS.NOT_READY;\n      this.openloginInstance = null;\n      this.privKeyProvider = null;\n    } else {\n      // ready to be connected again\n      this.status = ADAPTER_STATUS.READY;\n    }\n\n    this.emit(ADAPTER_EVENTS.DISCONNECTED);\n  }\n\n  async getUserInfo() {\n    if (this.status !== ADAPTER_STATUS.CONNECTED) throw WalletLoginError.notConnectedError(\"Not connected with wallet\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n    const userInfo = await this.openloginInstance.getUserInfo();\n    return userInfo;\n  } // should be called only before initialization.\n\n\n  setAdapterSettings(adapterSettings) {\n    if (this.status === ADAPTER_STATUS.READY) return;\n    const defaultOptions = getOpenloginDefaultOptions();\n    this.openloginOptions = _objectSpread(_objectSpread(_objectSpread({}, defaultOptions.adapterSettings), this.openloginOptions || {}), adapterSettings);\n  } // should be called only before initialization.\n\n\n  setChainConfig(customChainConfig) {\n    super.setChainConfig(customChainConfig);\n    this.currentChainNamespace = customChainConfig.chainNamespace;\n  }\n\n  async connectWithProvider(params) {\n    if (!this.chainConfig) throw WalletInitializationError.invalidParams(\"chainConfig is required before initialization\");\n    if (!this.openloginInstance) throw WalletInitializationError.notReady(\"openloginInstance is not ready\");\n\n    if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n      const {\n        SolanaPrivateKeyProvider\n      } = await import('@web3auth/solana-provider');\n      this.privKeyProvider = new SolanaPrivateKeyProvider({\n        config: {\n          chainConfig: this.chainConfig\n        }\n      });\n    } else if (this.currentChainNamespace === CHAIN_NAMESPACES.EIP155) {\n      const {\n        EthereumPrivateKeyProvider\n      } = await import('@web3auth/ethereum-provider');\n      this.privKeyProvider = new EthereumPrivateKeyProvider({\n        config: {\n          chainConfig: this.chainConfig\n        }\n      });\n    } else if (this.currentChainNamespace === CHAIN_NAMESPACES.OTHER) {\n      this.privKeyProvider = new CommonPrivateKeyProvider();\n    } else {\n      throw new Error(\"Invalid chainNamespace: \".concat(this.currentChainNamespace, \" found while connecting to wallet\"));\n    } // if not logged in then login\n\n\n    if (!this.openloginInstance.privKey && params) {\n      var _params$extraLoginOpt;\n\n      await this.openloginInstance.login(merge(this.loginSettings, {\n        loginProvider: params.loginProvider\n      }, {\n        extraLoginOptions: _objectSpread(_objectSpread({}, params.extraLoginOptions || {}), {}, {\n          login_hint: params.login_hint || ((_params$extraLoginOpt = params.extraLoginOptions) === null || _params$extraLoginOpt === void 0 ? void 0 : _params$extraLoginOpt.login_hint)\n        })\n      }));\n    }\n\n    let finalPrivKey = this.openloginInstance.privKey;\n\n    if (finalPrivKey) {\n      if (this.currentChainNamespace === CHAIN_NAMESPACES.SOLANA) {\n        const {\n          getED25519Key\n        } = await import('@toruslabs/openlogin-ed25519');\n        finalPrivKey = getED25519Key(finalPrivKey).sk.toString(\"hex\");\n      }\n\n      await this.privKeyProvider.setupProvider(finalPrivKey);\n      this.status = ADAPTER_STATUS.CONNECTED;\n      this.emit(ADAPTER_EVENTS.CONNECTED, {\n        adapter: WALLET_ADAPTERS.OPENLOGIN,\n        reconnected: !params\n      });\n    }\n  }\n\n}\n\nexport { OpenloginAdapter, getOpenloginDefaultOptions };\n//# sourceMappingURL=openloginAdapter.esm.js.map\n"]},"metadata":{},"sourceType":"module"}